{"date": "2024-03-29 02:35", "hash": "84f4b93a1270b492e4c54d5212da7a5b", "eval": {"HumanEval/155": [{"task_id": "HumanEval/155", "solution": "\ndef even_odd_count(num):\n    \"\"\"Given an integer, returns a tuple containing the count of even and odd digits in the number.\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        A tuple where the first element is the count of even digits and the second element is the count of odd digits.\n\n    Raises:\n        TypeError: If the input is not an integer.\n    \"\"\"\n    if not isinstance(num, int):\n        raise TypeError(\"Input must be an integer.\")\n    \n    num = abs(num)  # To handle negative numbers\n    even_count = 0\n    odd_count = 0\n\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num //= 10\n    \n    return (even_count, odd_count)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[0]], "plus_fail_tests": [[0]]}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "\ndef generate_integers(a: int, b: int) -> list[int]:\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    Args:\n        a: The first integer.\n        b: The second integer.\n\n    Returns:\n        A list of even numbers between a and b, sorted in ascending order.\n\n    Raises:\n        ValueError: If either a or b is not a positive integer.\n    \n    \"\"\"\n    if not (isinstance(a, int) and isinstance(b, int)):\n        raise ValueError(\"Both inputs must be integers.\")\n        \n    if a < 0 or b < 0:\n        raise ValueError(\"Inputs must be positive integers.\")\n        \n    # Swap the numbers if a > b\n    if a > b:\n        a, b = b, a\n    \n    return sorted(num for num in range(a, b + 1) if num % 2 == 0)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "\ndef compare_scores(game, guess):\n    \"\"\"Compares the scores of a game to the guesses of a player.\n\n    Args:\n        game: A list of integers representing the actual scores of each match in the game.\n        guess: A list of integers representing the guessed scores of each match by the player.\n\n    Returns:\n        A list of integers where each index represents how far off the corresponding guess was from the score. \n        If the guess is correct, the value at that index will be 0.\n\n    Raises:\n        ValueError: If game and guess are not lists or if they have different lengths.\n    \"\"\"\n    \n    # Checking if both inputs are lists\n    if not (isinstance(game, list) and isinstance(guess, list)):\n        raise ValueError(\"Both game and guess must be of type list.\")\n        \n    # Checking if both lists have the same length\n    if len(game) != len(guess):\n        raise ValueError(\"Game and guess must have the same number of elements.\")\n    \n    return [abs(g - gs) for g, gs in zip(game, guess)]\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "\ndef compare_one(a, b):\n    \"\"\"\n    This function takes integers, floats, or strings representing real numbers, \n    and returns the larger variable in its given variable type. Return None if the values are equal.\n\n    Args:\n        a: The first parameter to be compared. It can be an integer, float or string.\n        b: The second parameter to be compared. It can be an integer, float or string.\n\n    Returns:\n        The larger variable in its given variable type if the values are not equal. If they are equal, it returns None.\n\n    Raises:\n        ValueError: If either of the parameters is a string that cannot be converted to a number.\n    \"\"\"\n    \n    # Convert strings to floats if possible\n    try:\n        a = float(a) if type(a) == str else a\n        b = float(b) if type(b) == str else b\n    except ValueError as e:\n        raise ValueError(\"Both parameters should be numbers or convertible strings.\") from e\n    \n    # Compare the values and return accordingly\n    if a > b:\n        return a\n    elif b > a:\n        return b\n    else:\n        return None\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, "2,3"]], "plus_fail_tests": [["5,000", 5000]]}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "\ndef count_nums(arr):\n    \"\"\"\n    This function takes an array of integers and returns the number of elements which has a sum of digits > 0. \n    If a number is negative, then its first signed digit will be negative.\n\n    Args:\n        arr: An array of integers.\n\n    Returns:\n        The count of numbers in the array whose sum of digits is greater than zero.\n\n    Raises:\n        TypeError: If the input is not a list or if any element of the list is not an integer.\n    \"\"\"\n    \n    # Checking if arr is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input should be a list\")\n        \n    # Checking if all elements in arr are integers\n    for num in arr:\n        if not isinstance(num, int):\n            raise TypeError(\"All elements in the input list should be integers\")\n    \n    count = 0\n    for num in arr:\n        # If number is negative, make it positive\n        if num < 0:\n            num = -num\n            \n        # Calculate sum of digits\n        digit_sum = sum(int(digit) for digit in str(num))\n        \n        # Increment count if digit_sum > 0\n        if digit_sum > 0:\n            count += 1\n    \n    return count\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -2, 0]]], "plus_fail_tests": [[[-1, 0, 1]]]}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "\ndef f(n):\n    \"\"\"Compute a list of size n where the value at index i is either the factorial of i if i is even or the sum of numbers from 1 to i if i is odd.\n\n    Args:\n        n (int): The size of the list to be computed.\n\n    Returns:\n        list: A list of size n where each element at index i is either the factorial of i if i is even or the sum of numbers from 1 to i if i is odd.\n\n    Raises:\n        ValueError: If input parameter n is not a positive integer.\n    \"\"\"\n    \n    # Check that n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n        \n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0: # If index is even\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else: # If index is odd\n            sum_of_numbers = sum(range(i+1))\n            result.append(sum_of_numbers)\n            \n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate Mean Absolute Deviation around the mean of a dataset.\n\n    Args:\n        numbers: A list of floats for which to calculate MAD.\n\n    Returns:\n        The Mean Absolute Deviation (MAD) of the input data.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "\ndef words_string(s):\n    \"\"\"\n    This function splits a string of words separated by commas or spaces into an array of the words.\n\n    Args:\n        s (str): The input string to be split into words.\n\n    Returns:\n        list: A list of words in the string.\n\n    Raises:\n        TypeError: If the input is not a string.\n        \n    \"\"\"\n    \n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    return s.replace(\",\", \"\").split()\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Elephant,giraffe,,lion,zebra"]]}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Finds the strongest extension of a given class.\n\n    Args:\n        class_name: The name of the class (a string).\n        extensions: A list of extensions to be used to load additional classes to the class.\n\n    Returns:\n        A string in this format: ClassName.StrongestExtensionName.\n\n    Raises:\n        TypeError: If class_name is not a string or if extensions is not a list.\n        ValueError: If class_name is an empty string or if extensions is an empty list.\n    \"\"\"\n    # Checking the types of inputs\n    if not isinstance(class_name, str):\n        raise TypeError(\"Class name must be a string.\")\n    if not isinstance(extensions, list):\n        raise TypeError(\"Extensions must be a list.\")\n    \n    # Checking for empty strings or empty lists\n    if class_name == \"\":\n        raise ValueError(\"Class name cannot be an empty string.\")\n    if len(extensions) == 0:\n        raise ValueError(\"Extensions list cannot be empty.\")\n        \n    # Calculating the strength of each extension and finding the strongest one\n    strongest_extension = extensions[0]\n    max_strength = sum(1 for c in strongest_extension if c.isupper()) - \\\n                  sum(1 for c in strongest_extension if c.islower())\n    \n    for ext in extensions:\n        strength = sum(1 for c in ext if c.isupper()) - \\\n                   sum(1 for c in ext if c.islower())\n        \n        if strength > max_strength:\n            strongest_extension = ext\n            max_strength = strength\n    \n    return class_name + \".\" + strongest_extension\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["", ["HhAas", "okIWILL123"]]]}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "\nimport hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    Args:\n        text (str): The input string to be hashed.\n\n    Returns:\n        str or None: The MD5 hash of the input string if it's not an empty string, otherwise None.\n\n    Raises:\n        TypeError: If 'text' is not a string.\n    \"\"\"\n    \n    # Checking if text is a string\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n        \n    # Return None for empty strings\n    if text == \"\":\n        return None\n    \n    # Calculate and return the MD5 hash of the input string\n    return hashlib.md5(text.encode()).hexdigest()\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"Detects if the balance of a bank account falls below zero at any point.\n\n    Args:\n        operations: A list of deposit and withdrawal operations on a bank account that starts with zero balance.\n\n    Returns:\n        True if the balance of the account falls below zero at any point, False otherwise.\n\n    Raises:\n        TypeError: If the input is not a list or contains non-integer values.\n    \"\"\"\n    \n    # Checking if operations is a list and containing only integers\n    if not isinstance(operations, list) or not all(isinstance(i, int) for i in operations):\n        raise TypeError(\"Input should be a list of integers.\")\n        \n    balance = 0  # Initializing the account balance to zero\n    \n    # Iterating over each operation\n    for op in operations:\n        balance += op  # Updating the balance\n        if balance < 0:  # If the balance falls below zero at any point\n            return True\n            \n    return False  # If the balance never falls below zero\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "\ndef cycpattern_check(a , b):\n    \"\"\"Check if the second word or any of its rotations is a substring in the first word.\n\n    Args:\n        a (str): The first string to check for substrings.\n        b (str): The second string which may be a rotation of the first string.\n\n    Returns:\n        bool: True if the second word or any of its rotations is a substring in the first word, False otherwise.\n\n    Raises:\n        TypeError: If either `a` or `b` are not strings.\n    \"\"\"\n    \n    # Check that both inputs are strings\n    if not all(isinstance(i, str) for i in [a, b]):\n        raise TypeError(\"Both arguments must be of type string.\")\n        \n    # Generate all rotations of `b`\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    \n    # Check if any rotation is a substring of `a`\n    return any(rotation in a for rotation in rotations)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["", ""]]}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "\ndef truncate_number(number: float) -> float:\n    \"\"\"Given a positive floating point number, it can be decomposed into an integer part \n    (largest integer smaller than given number) and decimals (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    if not isinstance(number, float):\n        raise ValueError(\"Input must be a floating point number.\")\n    elif number < 0:\n        raise ValueError(\"Input must be a positive number.\")\n        \n    integer_part = int(number)\n    decimal_part = number - integer_part\n    \n    return decimal_part\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "\ndef make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, this function creates a pile of stones where the first level has n stones. \n    The number of stones in each subsequent level is either the next odd or even number depending on whether n is odd or even respectively.\n    \n    Args:\n        n (int): A positive integer representing the number of stones in the first level.\n        \n    Returns:\n        list: A list where each element represents the number of stones in a level, starting from the second level.\n        \n    Raises:\n        ValueError: If the input is not a positive integer.\n    \"\"\"\n    \n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    pile = [n]\n    next_num = n + 1 if n % 2 == 0 else n + 2\n    \n    while len(pile) < n:\n        pile.append(next_num)\n        next_num += 2\n        \n    return pile\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[4]], "plus_fail_tests": [[2]]}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Args:\n        n: A positive integer less than or equal to 10^3.\n\n    Returns:\n        A tuple where the first element is the count of even palindrome numbers and the second element is the count of odd palindrome numbers.\n\n    Raises:\n        ValueError: If n is not a positive integer less than or equal to 10^3.\n    \"\"\"\n    \n    if not isinstance(n, int) or n <= 0 or n > 10**3:\n        raise ValueError(\"Input must be a positive integer less than or equal to 10^3.\")\n        \n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n+1):\n        if str(i) == str(i)[::-1]: # Check if the number is a palindrome.\n            if i % 2 == 0: # If it's even.\n                even_count += 1\n            else: # If it's odd.\n                odd_count += 1\n                \n    return (even_count, odd_count)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "\ndef tribonacci(n):\n    \"\"\"Computes the first n + 1 numbers of the Tribonacci sequence.\n\n    Args:\n        n: A non-negative integer representing the number of elements to compute in the sequence.\n\n    Returns:\n        A list containing the first n + 1 numbers of the Tribonacci sequence.\n\n    Raises:\n        ValueError: If the input is not a non-negative integer.\n    \"\"\"\n    if type(n) != int or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Initialize base cases\n    tribonacci_sequence = [1, 3] + [0] * (n - 1)\n    \n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            tribonacci_sequence[i] = 1 + i // 2\n        else:\n            tribonacci_sequence[i] = tribonacci_sequence[i - 1] + tribonacci_sequence[i - 2] + tribonacci_sequence[i + 1]\n    \n    return tribonacci_sequence[:n+1]\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n can be expressed as the sum of exactly 4 positive even numbers, False otherwise.\n\n    Raises:\n        TypeError: If input is not an integer.\n    \"\"\"\n    \n    # Checking if input is an integer\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n        \n    # The sum of 4 positive even numbers can only be equal to n if n is greater than or equal to 2*4 and is divisible by 2.\n    return n >= 2*4 and n % 2 == 0\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "\ndef special_factorial(n):\n    \"\"\"Calculates the Brazilian factorial of a given number.\n\n    Args:\n        n (int): The number to calculate the Brazilian factorial for.\n\n    Returns:\n        int: The result of the Brazilian factorial operation.\n\n    Raises:\n        ValueError: If the input is not an integer or if it's less than 0.\n    \"\"\"\n    # Checking if n is a non-negative integer\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"The input must be a non-negative integer.\")\n    \n    # Calculating the factorial\n    result = 1\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            result *= j\n            \n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[500]]}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "\nfrom typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers`\n\n    Args:\n        numbers: A list of integers.\n        delimeter: An integer to be inserted between each pair of consecutive elements in the list.\n\n    Returns:\n        A new list with the 'delimeter' inserted between each pair of consecutive elements from the input list.\n\n    Raises:\n        TypeError: If `numbers` is not a list or if any element of `numbers` is not an integer, or if `delimeter` is not an integer.\n        \n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"'numbers' must be a list\")\n    \n    if not all(isinstance(i, int) for i in numbers):\n        raise TypeError(\"All elements of 'numbers' must be integers\")\n        \n    if not isinstance(delimeter, int):\n        raise TypeError(\"'delimeter' must be an integer\")\n    \n    result = []\n    for num in numbers:\n        result.append(num)\n        result.append(delimeter)\n    \n    # Remove the last 'delimeter' as it is after the last number\n    if len(result) > 0:\n        result.pop()\n        \n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "\ndef product_of_odd_digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        int: The product of the odd digits in n. If all digits are even, returns 0.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    product = 1\n    has_odd = False\n    for digit in str(n):\n        if int(digit) % 2 != 0:\n            product *= int(digit)\n            has_odd = True\n            \n    return product if has_odd else 0\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "\ndef move_one_ball(arr):\n    \"\"\"Determine if it is possible to get an array sorted in non-decreasing order by performing right shift operation.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the given array can be sorted in non-decreasing order by performing at most one right shift operation, False otherwise.\n\n    Raises:\n        ValueError: If the input is not a list or if it contains non-integer elements.\n    \"\"\"\n    \n    # Checking if arr is a list and containing only integers\n    if not isinstance(arr, list):\n        raise ValueError(\"Input should be a list\")\n    for i in arr:\n        if not isinstance(i, int):\n            raise ValueError(\"List should contain only integers\")\n    \n    # If the array is empty or contains one element it's already sorted\n    if len(arr) < 2:\n        return True\n    \n    # Finding the index of the maximum value in arr\n    max_index = arr.index(max(arr))\n    \n    # Checking if the array can be sorted by performing at most one right shift operation\n    for i in range(len(arr) - 1):\n        if arr[(i + max_index + 1) % len(arr)] < arr[(i + max_index) % len(arr)]:\n            return False\n    \n    return True\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[5, 6, 7, 8, 1, 2, 3, 4]]]}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "\ndef largest_smallest_integers(lst):\n    \"\"\"\n    Create a function that returns a tuple (a, b), where 'a' is the largest of negative integers, \n    and 'b' is the smallest of positive integers in a list. If there is no negative or positive integers, \n    return them as None.\n\n    Args:\n        lst: A list of integers.\n\n    Returns:\n        A tuple (a, b) where 'a' is the largest negative integer and 'b' is the smallest positive integer in the list.\n        If there are no negative or positive integers, return them as None.\n\n    Raises:\n        ValueError: If the input is not a list of integers.\n    \"\"\"\n    \n    if not all(isinstance(i, int) for i in lst):\n        raise ValueError(\"All elements in the list must be integers.\")\n        \n    negatives = [num for num in lst if num < 0]\n    positives = [num for num in lst if num > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "\nfrom typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each other.\n    \n    Args:\n        numbers: A list of floats with at least two elements.\n        \n    Returns:\n        A tuple containing the two closest numbers from the input list, in ascending order.\n        \n    Raises:\n        ValueError: If the input list has less than two elements.\n     \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must have at least two elements.\")\n    \n    numbers.sort()  # Sorting the list in ascending order\n    closest_pair = (numbers[0], numbers[1])  # Initialize with first two elements\n    min_difference = abs(closest_pair[0] - closest_pair[1])  # Initial minimum difference\n    \n    for i in range(1, len(numbers) - 1):\n        current_pair = (numbers[i], numbers[i + 1])\n        diff = abs(current_pair[0] - current_pair[1])\n        \n        if diff < min_difference:\n            closest_pair = current_pair\n            min_difference = diff\n            \n    return closest_pair if closest_pair[0] <= closest_pair[1] else (closest_pair[1], closest_pair[0])\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "\ndef flip_case(string: str) -> str:\n    \"\"\"For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n\n    Args:\n        string: The input string that needs to be flipped.\n\n    Returns:\n        A new string with all the case of characters flipped.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError('The input must be a string')\n    \n    return ''.join([char.upper() if char.islower() else char.lower() for char in string])\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"Find how many times a given substring can be found in the original string. Count overlaping cases.\n\n    Args:\n        string: The main string where we are looking for the substring.\n        substring: The smaller string that we want to find in the main string.\n\n    Returns:\n        An integer representing how many times the substring appears in the string, including overlapping cases.\n\n    Raises:\n        TypeError: If either of the inputs is not a string.\n    \"\"\"\n    # Check if both arguments are strings\n    if not all(isinstance(i, str) for i in [string, substring]):\n        raise TypeError(\"Both arguments must be strings.\")\n    \n    return sum(1 for i in range(len(string)) if string.startswith(substring, i))\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    Args:\n        string: The input string from which to count the number of distinct characters.\n\n    Returns:\n        An integer representing the number of distinct characters in the input string.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError('The input must be a string')\n    \n    return len(set(string.lower()))\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Perform binary XOR on two strings of 1s and 0s.\n\n    Args:\n        a: The first string consisting only of 1s and 0s.\n        b: The second string consisting only of 1s and 0s.\n\n    Returns:\n        A string that is the result of performing XOR on the two input strings.\n\n    Raises:\n        ValueError: If the input strings are not valid binary strings (i.e., they contain characters other than '1' or '0').\n    \"\"\"\n    \n    # Check if inputs are valid binary strings\n    for s in [a, b]:\n        if any(c != '0' and c != '1' for c in s):\n            raise ValueError('Inputs must be binary strings (containing only 1s and 0s)')\n    \n    # Perform XOR operation on the two input strings\n    result = ''\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n            \n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "\nfrom typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"Filter an input list of strings only for ones that start with a given prefix.\n\n    Args:\n        strings: A list of strings to be filtered.\n        prefix: The prefix to filter the strings by.\n\n    Returns:\n        A new list containing only the strings from the input list that start with the specified prefix.\n\n    Raises:\n        TypeError: If 'strings' is not a list or 'prefix' is not a string.\n    \"\"\"\n    if not isinstance(strings, list) or not all(isinstance(s, str) for s in strings):\n        raise TypeError(\"'strings' must be a list of strings.\")\n    if not isinstance(prefix, str):\n        raise TypeError(\"'prefix' must be a string.\")\n    \n    return [s for s in strings if s.startswith(prefix)]\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["hah", "hah"]]}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "\ndef encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and \n    returns a string encrypted with the alphabet being rotated. The alphabet should be \n    rotated in a manner such that the letters shift down by two multiplied to two places.\n\n    Args:\n        s (str): The input string to encrypt.\n\n    Returns:\n        str: The encrypted string.\n\n    Raises:\n        TypeError: If the argument is not a string.\n    \"\"\"\n    \n    if not isinstance(s, str):\n        raise TypeError('The argument must be a string')\n        \n    result = \"\"\n    for char in s:\n        # Check if character is an alphabet\n        if char.isalpha():\n            # Get ASCII value of the character\n            ascii_val = ord(char)\n            \n            # Shift down by two multiplied to two places\n            new_ascii_val = ascii_val + (2 * 2)\n            \n            # If it's a lowercase letter\n            if char.islower():\n                # Wrap around from 'z' to 'a'\n                if new_ascii_val > ord('z'):\n                    new_ascii_val -= 26\n                    \n            # If it's an uppercase letter\n            elif char.isupper():\n                # Wrap around from 'Z' to 'A'\n                if new_ascii_val > ord('Z'):\n                    new_ascii_val -= 26\n            \n            result += chr(new_ascii_val)\n        else:\n            result += char\n    \n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "\ndef incr_list(lst: list) -> list:\n    \"\"\"Return a new list where each element is incremented by 1.\n\n    Args:\n        lst: The input list of integers.\n\n    Returns:\n        A new list with elements incremented by 1.\n\n    Raises:\n        TypeError: If the provided argument is not a list.\n        ValueError: If the provided list contains non-integer values.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The input should be a list.\")\n    \n    try:\n        return [x + 1 for x in lst]\n    except TypeError as e:\n        raise ValueError(\"All elements of the list should be integers.\") from e\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "\ndef get_row(lst, x):\n    \"\"\"Find integers x in the list and return their coordinates.\n\n    Args:\n        lst: A 2 dimensional data as a nested lists.\n        x: The integer to find in the list.\n\n    Returns:\n        List of tuples (row, columns), starting with 0, sorted initially by rows in ascending order and then by columns in descending order.\n\n    Raises:\n        TypeError: If lst is not a list or x is not an integer.\n    \"\"\"\n    if not isinstance(lst, list) or not all(isinstance(i, list) for i in lst):\n        raise TypeError(\"lst must be a 2D list\")\n    if not isinstance(x, int):\n        raise TypeError(\"x must be an integer\")\n    \n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index in sorted([i for i, value in enumerate(row) if value == x], reverse=True):\n            coordinates.append((row_index, col_index))\n    \n    return sorted(coordinates, key=lambda x: (x[0], -x[1]))\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "\ndef smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that need to be changed \n    to make the array palindromic. A palindromic array is an array that is read the same backwards and forwards. \n    In one change, you can change one element to any other element.\n\n    Args:\n        arr: The input list of integers.\n\n    Returns:\n        The minimum number of elements that need to be changed to make the array palindromic.\n\n    Raises:\n        TypeError: If the input is not a list or if it contains non-integer values.\n    \"\"\"\n    \n    # Checking if arr is a list and if all its elements are integers\n    if not isinstance(arr, list):\n        raise TypeError(\"The input should be a list.\")\n    for i in arr:\n        if not isinstance(i, int):\n            raise TypeError(\"All elements of the list should be integers.\")\n    \n    # Initializing variables\n    n = len(arr)\n    changes = 0\n    \n    # Comparing corresponding elements from start and end of array\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n            \n    return changes\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "\ndef triangle_area(side_length: float, height: float) -> float:\n    \"\"\"Calculate the area of a triangle given its side length and height.\n\n    Args:\n        side_length: The length of one side of the triangle.\n        height: The perpendicular distance between the side and the line from the vertex to the opposite side.\n\n    Returns:\n        The area of the triangle.\n\n    Raises:\n        ValueError: If either `side_length` or `height` is less than zero.\n    \"\"\"\n    if side_length < 0 or height < 0:\n        raise ValueError(\"Both side length and height must be non-negative.\")\n    \n    return 0.5 * side_length * height\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "\ndef total_match(lst1, lst2):\n    \"\"\"\n    This function accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n    If the two lists have the same number of chars, return the first list.\n\n    Args:\n        lst1: The first list of strings.\n        lst2: The second list of strings.\n\n    Returns:\n        The list that has total number of chars in the all strings of the list less than \n        the other list or the first list if both lists have the same number of chars.\n\n    Raises:\n        TypeError: If either lst1 or lst2 is not a list.\n        ValueError: If either lst1 or lst2 contains non-string elements.\n    \"\"\"\n    \n    # Check if both inputs are lists\n    if not (isinstance(lst1, list) and isinstance(lst2, list)):\n        raise TypeError(\"Both arguments must be of type list.\")\n        \n    # Check if both lists contain only strings\n    for i in lst1 + lst2:\n        if not isinstance(i, str):\n            raise ValueError(\"All elements in the lists must be of type string.\")\n    \n    # Calculate total number of chars in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Return the list with less total number of chars or the first one if equal\n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "\ndef is_happy(s):\n    \"\"\"Check if the string s is happy or not.\n\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n\n    Args:\n        s: The input string to be checked.\n\n    Returns:\n        True if the string is happy, False otherwise.\n\n    Raises:\n        TypeError: If the argument is not a string.\n    \"\"\"\n    \n    # Check that s is a string\n    if not isinstance(s, str):\n        raise TypeError(\"The argument must be a string.\")\n        \n    # Check length of s\n    if len(s) < 3:\n        return False\n    \n    # Check every 3 consecutive letters are distinct\n    for i in range(len(s)-2):\n        if len(set(s[i:i+3])) != 3:\n            return False\n        \n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "\nfrom typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"Parses a string representing musical notes in a special ASCII format \n    and returns list of integers corresponding to how many beats does each note last.\n\n    Args:\n        music_string: A string representing musical notes in the following format:\n            'o' - whole note, lasts four beats\n            'o|' - half note, lasts two beats\n            '.|' - quater note, lasts one beat\n\n    Returns:\n        List of integers corresponding to how many beats does each note last.\n\n    Raises:\n        ValueError: If the input string contains a character that is not 'o', 'o|' or '.|'.\n    \"\"\"\n    \n    # Define a dictionary mapping notes to their lengths in beats\n    note_lengths = {'o': 4, 'o|': 2, '.|': 1}\n\n    try:\n        # Split the string into individual notes and map each one to its length in beats\n        return [note_lengths[note.strip()] for note in music_string.split(' ')]\n    except KeyError as e:\n        raise ValueError(f\"Invalid note: {e}\") from None\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n\n    Args:\n        string: The input string to be transformed into a palindrome.\n\n    Returns:\n        The shortest palindrome that begins with the supplied string.\n\n    Raises:\n        TypeError: If the input is not a string.\n        \n    \"\"\"\n    \n    if not isinstance(string, str):\n        raise TypeError('Input must be a string')\n    \n    # Find the longest postfix of supplied string that is a palindrome.\n    for i in range(len(string), -1, -1):\n        suffix = string[i:]\n        \n        if is_palindrome(suffix):\n            prefix = string[:i]\n            \n            # Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n            return string + prefix[::-1]\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "\nfrom typing import List\n\ndef concatenate_strings(string_list: List[str]) -> str:\n    \"\"\"Concatenates a list of strings into a single string.\n\n    Args:\n        string_list: A list of strings to be concatenated.\n\n    Returns:\n        The resulting string after all input strings have been concatenated.\n\n    Raises:\n        TypeError: If the provided argument is not a list or if it contains non-string elements.\n    \"\"\"\n    # Check that the input is a list\n    if not isinstance(string_list, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check that all elements in the list are strings\n    for element in string_list:\n        if not isinstance(element, str):\n            raise TypeError(\"All elements in the list must be strings\")\n            \n    return ''.join(string_list)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"Sort a space-delimited string of numberals from 'zero' to 'nine'.\n\n    Args:\n        numbers: A space-delimited string containing numberals from 'zero' to 'nine'.\n\n    Returns:\n        The sorted string of numberals.\n\n    Raises:\n        ValueError: If the input string contains a numeral not in the range 'zero' to 'nine'.\n    \"\"\"\n    \n    # Define a dictionary mapping number names to their corresponding integers\n    number_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    \n    # Split the input string into a list of number names\n    numbers_list = numbers.split()\n    \n    # Check if all number names in the list are valid\n    for numeral in numbers_list:\n        if numeral not in number_dict:\n            raise ValueError(f\"Invalid numeral: {numeral}\")\n            \n    # Sort the list of number names based on their corresponding integers\n    sorted_numbers = sorted(numbers_list, key=lambda x: number_dict[x])\n    \n    # Join the sorted list back into a string and return it\n    return \" \".join(sorted_numbers)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "\nfrom typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return result\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 4, 3, 5]]], "plus_fail_tests": []}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "\ndef is_multiply_prime(n):\n    \"\"\"Check if a number can be expressed as the product of exactly 3 prime numbers.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number can be expressed as the product of exactly 3 prime numbers, False otherwise.\n\n    Raises:\n        ValueError: If input is not an integer or less than 2.\n    \"\"\"\n    # Checking if n is an integer and greater than 1\n    if not isinstance(n, int) or n < 2:\n        raise ValueError(\"Input must be an integer greater than 1.\")\n    \n    # Function to check if a number is prime\n    def is_prime(num):\n        for i in range(2, num):\n            if (num % i) == 0:\n                return False\n        return True\n\n    primes = [i for i in range(2, n+1) if is_prime(i)]\n    \n    # Checking if the number can be expressed as a product of exactly 3 prime numbers\n    count = 0\n    for p1 in primes:\n        if n % p1 == 0:\n            quotient = n // p1\n            for p2 in primes:\n                if quotient % p2 == 0 and is_prime(quotient // p2):\n                    count += 1\n    \n    return count == 3\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[30]], "plus_fail_tests": [[78]]}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "\ndef numerical_letter_grade(gpas):\n    \"\"\"This function takes a list of GPAs and returns the corresponding letter grades.\n\n    Args:\n        gpas: A list of GPAs.\n\n    Returns:\n        A list of letter grades corresponding to the input GPAs.\n\n    Raises:\n        ValueError: If any GPA is not a number or if it's out of range [0, 4].\n    \"\"\"\n    \n    # Define grade ranges and their corresponding letters\n    grade_ranges = {(4.0, float('inf')): 'A+', (3.7, 4.0): 'A', (3.3, 3.7): 'A-',\n                    (3.0, 3.3): 'B+', (2.7, 3.0): 'B', (2.3, 2.7): 'B-',\n                    (2.0, 2.3): 'C+', (1.7, 2.0): 'C', (1.3, 1.7): 'C-',\n                    (1.0, 1.3): 'D+', (0.7, 1.0): 'D', (0.0, 0.7): 'D-',\n                    (-float('inf'), 0.0): 'E'}\n    \n    # Check if all GPAs are numbers and in the range [0, 4]\n    for gpa in gpas:\n        if not isinstance(gpa, (int, float)) or gpa < 0 or gpa > 4:\n            raise ValueError('All GPAs must be numbers between 0 and 4.')\n    \n    # Convert each GPA to its corresponding letter grade\n    letter_grades = []\n    for gpa in gpas:\n        for (lower, upper), letter in grade_ranges.items():\n            if lower <= gpa < upper:\n                letter_grades.append(letter)\n                break\n    \n    return letter_grades\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Given a list of numbers (of at least two elements), apply a linear transform to that list, \n    such that the smallest number will become 0 and the largest will become 1.\n\n    Args:\n        numbers: A list of floats with at least two elements.\n\n    Returns:\n        A new list where each element is rescaled based on its position in the sorted version of the input list.\n\n    Raises:\n        ValueError: If the input list has less than two elements or if any element is not a number.\n    \"\"\"\n    \n    # Checking for valid input\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must have at least two elements.\")\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"All elements of the input list must be numbers.\")\n    \n    # Sorting the numbers and finding min and max\n    sorted_numbers = sorted(numbers)\n    smallest = sorted_numbers[0]\n    largest = sorted_numbers[-1]\n    \n    # Calculating range\n    rng = largest - smallest if largest != smallest else 1\n    \n    # Rescaling each number and returning the result\n    return [(x - smallest) / rng for x in numbers]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "\ndef will_it_fly(q, w):\n    \"\"\"This function returns True if the object q will fly, and False otherwise. \n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Args:\n        q: A list of integers representing the weights of an object.\n        w: An integer representing the maximum possible weight that the object can carry.\n\n    Returns:\n        True if the object will fly, False otherwise.\n\n    Raises:\n        TypeError: If q is not a list or if any element in q is not an integer.\n        ValueError: If w is not a positive integer.\n    \"\"\"\n    \n    # Checking if q is a list of integers and w is a positive integer\n    if not isinstance(q, list) or not all(isinstance(i, int) for i in q):\n        raise TypeError(\"The first argument must be a list of integers.\")\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"The second argument must be a positive integer.\")\n    \n    # Checking if the object is balanced (a palindrome) and its total weight is less than or equal to w\n    return q == q[::-1] and sum(q) <= w\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "\ndef anti_shuffle(s):\n    \"\"\"\n    This function takes a string and returns an ordered version of it. \n    Ordered version of string is a string where all words (separated by space) are replaced by a new word where all the characters arranged in ascending order based on ascii value.\n    \n    Args:\n        s: The input string to be anti-shuffled.\n        \n    Returns:\n        A string with each word sorted in ascending order based on ASCII values.\n        \n    Raises:\n        TypeError: If the input is not a string.\n    \n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    words = s.split(' ')\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(sorted_words)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "\ndef sort_array(arr):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n     * don't change the given array.\n\n    Examples:\n     * sort_array([]) => []\n     * sort_array([5]) => [5]\n     * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n     * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    if not arr:\n        return []\n    else:\n        sum_first_last = arr[0] + arr[-1]\n        sorted_arr = sorted(arr)\n        if sum_first_last % 2 == 0:\n            return sorted_arr[::-1]\n        else:\n            return sorted_arr\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    This function takes a list of integers as an input. \n    It returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        bool: True if there are two distinct elements in the list that sum to zero, False otherwise.\n\n    Raises:\n        TypeError: If the input is not a list or if the list contains non-integer values.\n    \"\"\"\n    \n    # Checking if the input is a list and if it contains only integers\n    if not isinstance(l, list):\n        raise TypeError(\"The input should be a list.\")\n    for i in l:\n        if not isinstance(i, int):\n            raise TypeError(\"All elements of the list should be integers.\")\n    \n    # Checking if there are two distinct elements that sum to zero\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "\ndef change_base(x: int, base: int) -> str:\n    \"\"\"Change numerical base of input number x to base.\n\n    Args:\n        x (int): The number to be converted.\n        base (int): The base to convert the number into.\n\n    Returns:\n        str: The string representation after the conversion.\n\n    Raises:\n        ValueError: If base is greater than 10 or less than 2.\n\n    \"\"\"\n    \n    if not(2 <= base <= 10):\n        raise ValueError(\"Base must be between 2 and 10\")\n        \n    digits = \"0123456789\"\n    result = \"\"\n    \n    while x > 0:\n        digit_value = x % base\n        result = digits[digit_value] + result\n        x //= base\n        \n    return result if result else \"0\"\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "\ndef check_dict_case(dictionary):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    \n    Args:\n        dictionary: A dictionary to check its keys' cases.\n        \n    Returns:\n        True if all keys are either lowercase or uppercase, False otherwise.\n        \n    Raises:\n        ValueError: If the provided argument is not a dictionary.\n    \"\"\"\n    \n    # Check if input is a dictionary\n    if not isinstance(dictionary, dict):\n        raise ValueError(\"The provided argument must be a dictionary.\")\n    \n    # Return False for empty dictionaries\n    if len(dictionary) == 0:\n        return False\n        \n    # Get the first key and check its case\n    first_key = next(iter(dictionary))\n    is_lower = first_key.islower()\n    \n    # Check all keys for their case\n    for key in dictionary:\n        if (is_lower and not key.islower()) or (not is_lower and not key.isupper()):\n            return False\n            \n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "\ndef correct_bracketing(brackets: str) -> bool:\n    \"\"\"Check if every opening bracket has a corresponding closing bracket.\n\n    Args:\n        brackets: A string of \"(\" and \")\".\n\n    Returns:\n        True if every opening bracket has a corresponding closing bracket, False otherwise.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    # Check that the input is a string\n    if not isinstance(brackets, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Initialize a counter for open brackets\n    count = 0\n    \n    # Iterate over each character in the string\n    for char in brackets:\n        # If the character is an opening bracket, increment the counter\n        if char == \"(\":\n            count += 1\n        # If the character is a closing bracket, decrement the counter\n        elif char == \")\":\n            count -= 1\n        \n        # If the counter goes negative, there's a closing bracket without a corresponding opening bracket\n        if count < 0:\n            return False\n    \n    # If the counter is not zero at the end, there are unmatched opening brackets\n    return count == 0\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "\ndef any_int(x, y, z):\n    \"\"\"\n    This function takes 3 numbers as input. It returns True if one of the numbers is equal to the sum of the other two, and all numbers are integers. Otherwise it returns False.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n        z (int): The third number.\n\n    Returns:\n        bool: True if one of the numbers is equal to the sum of the other two, and all numbers are integers. False otherwise.\n\n    Raises:\n        TypeError: If any of the inputs is not an integer.\n    \"\"\"\n    \n    # Checking if all inputs are integers\n    if not all(isinstance(i, int) for i in [x, y, z]):\n        raise TypeError(\"All inputs must be integers\")\n        \n    return x == y + z or y == x + z or z == x + y\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2.5, 2, 3]], "plus_fail_tests": [[143.7, -20, -123.7]]}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "\ndef digitSum(s):\n    \"\"\"Calculate the sum of ASCII codes for uppercase characters in a string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The sum of ASCII codes for uppercase characters in the string.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    return sum(ord(c) for c in s if c.isupper())\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n >1 and is not a prime.\n\n    Args:\n        n: The number to find the largest prime factor for.\n\n    Returns:\n        The largest prime factor of n.\n\n    Raises:\n        ValueError: If n <= 1, as there are no prime factors for these numbers.\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    \n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "\ndef monotonic(lst):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n\n    Args:\n        lst (list): The input list to check for monotonicity.\n\n    Returns:\n        bool: True if the list is monotonic, False otherwise.\n\n    Raises:\n        TypeError: If the input is not a list.\n    \"\"\"\n    # Check that the input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Return True for empty or single-element lists\n    if len(lst) < 2:\n        return True\n    \n    # Check if the list is monotonic increasing\n    diffs = [x - i for i, x in enumerate(lst)]\n    if all(diff > 0 for diff in diffs):\n        return True\n    \n    # Check if the list is monotonic decreasing\n    if all(diff < 0 for diff in diffs):\n        return True\n    \n    # If neither condition is met, the list is not monotonic\n    return False\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 20, 4, 10]]], "plus_fail_tests": [[[1, 1, 1, 1, 1]]]}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "\ndef encode_shift(s: str) -> str:\n    \"\"\"Encodes a string by shifting every character by 5 in the alphabet.\n\n    Args:\n        s: The string to be encoded.\n\n    Returns:\n        The encoded string.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    return \"\".join([chr(((ord(ch) - ord('a') + 5) % 26) + ord('a')) for ch in s])\n\ndef decode_shift(s: str) -> str:\n    \"\"\"Decodes a string that was encoded with the encode_shift function.\n\n    Args:\n        s: The string to be decoded.\n\n    Returns:\n        The decoded string.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    return \"\".join([chr(((ord(ch) - ord('a') - 5) % 26) + ord('a')) for ch in s])\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "\ndef max_element(lst: list):\n    \"\"\"Return maximum element in the list.\n\n    Args:\n        lst (list): The input list of numbers.\n\n    Returns:\n        int or float: The maximum number in the list. If the list is empty, returns None.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list does not contain any numeric elements.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list.\")\n    \n    if len(lst) == 0:\n        return None\n    \n    try:\n        max_value = max(lst)\n    except TypeError as e:\n        raise ValueError(\"List should contain only numeric elements.\") from e\n        \n    return max_value\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/68": [{"task_id": "HumanEval/68", "solution": "\ndef pluck(arr):\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes\n    this function will pluck one of the nodes with smallest even value and return it.\n    If multiple nodes with the same smallest even value are found, it returns the node that has smallest index.\n    The plucked node is returned in a list [smallest_value, its index].\n    If there are no even values or the given array is empty, it returns an empty list.\n\n    Args:\n        arr (List[int]): An array representing a branch of a tree with non-negative integer nodes.\n\n    Returns:\n        List[Union[int, str], Union[int, str]]: A list containing the smallest even value and its index. \n                                              If there are no even values or the given array is empty, it returns an empty list.\n    \n    Raises:\n        ValueError: If the input array contains non-integer elements.\n    \"\"\"\n    # Check if all elements in arr are integers\n    for i in arr:\n        if not isinstance(i, int):\n            raise ValueError(\"All elements in the array should be integers.\")\n    \n    # Filter out even numbers and their indices\n    evens = [(val, idx) for idx, val in enumerate(arr) if val % 2 == 0]\n    \n    # If there are no even numbers return an empty list\n    if not evens:\n        return []\n    \n    # Sort the list of tuples by value and index\n    evens.sort()\n    \n    # Return the smallest even number and its index\n    return [evens[0][0], evens[0][1]]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "\nimport math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    \"\"\"Evaluates polynomial with coefficients xs at point x.\n\n    Args:\n        xs: A list of coefficients for the polynomial.\n        x: The value at which to evaluate the polynomial.\n\n    Returns:\n        The result of evaluating the polynomial at x.\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\"Finds a zero of a polynomial with coefficients xs.\n\n    Args:\n        xs: A list of coefficients for the polynomial. The number of coefficients must be even, and the last non-zero coefficient is used to estimate the zero point.\n\n    Returns:\n        A zero of the polynomial.\n\n    Raises:\n        ValueError: If the number of coefficients is not even or if there are no non-zero coefficients.\n    \"\"\"\n    # Check that the number of coefficients is even and there's at least one non-zero coefficient\n    if len(xs) % 2 == 0 and any(coeff != 0 for coeff in xs):\n        # Use the largest non-zero coefficient to estimate a zero point\n        max_coeff = max([abs(coeff) for coeff in xs])\n        return -max_coeff / xs[-1]\n    else:\n        raise ValueError(\"The number of coefficients must be even and there must be at least one non-zero coefficient.\")\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "\ndef search(lst):\n    \"\"\"Return the greatest integer greater than zero that has a frequency \n       greater than or equal to its value in the given list. If no such number exists, return -1.\n\n    Args:\n        lst (list of int): A non-empty list of positive integers.\n\n    Returns:\n        int: The greatest integer that meets the criteria described above. \n             If no such number exists, returns -1.\n\n    Raises:\n        ValueError: If the input is not a list or if it contains non-positive integers.\n    \"\"\"\n    \n    # Checking if lst is a list and if all elements are positive integers\n    if not isinstance(lst, list) or not all(isinstance(i, int) and i > 0 for i in lst):\n        raise ValueError(\"Input should be a non-empty list of positive integers\")\n    \n    # Counting the frequency of each number in the list\n    freq = {num: lst.count(num) for num in set(lst)}\n    \n    # Finding numbers that meet the criteria and returning the maximum one\n    result = max([num for num, count in freq.items() if num <= count], default=-1)\n    \n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "\ndef correct_bracketing(brackets: str) -> bool:\n    \"\"\"Check if every opening bracket has a corresponding closing bracket.\n\n    Args:\n        brackets: A string of \"<\" and \">\".\n\n    Returns:\n        True if every opening bracket has a corresponding closing bracket, False otherwise.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    # Check that the input is a string\n    if not isinstance(brackets, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Initialize counter for open brackets\n    open_count = 0\n    \n    # Iterate over each character in the string\n    for char in brackets:\n        # If the character is an opening bracket, increment the counter\n        if char == \"<\":\n            open_count += 1\n        # If the character is a closing bracket, decrement the counter\n        elif char == \">\":\n            open_count -= 1\n        \n        # If at any point the counter goes negative, return False\n        if open_count < 0:\n            return False\n    \n    # If the counter is 0 after iterating over all characters, return True\n    # Otherwise, return False\n    return open_count == 0\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "\ndef encode(message):\n    \"\"\"Encodes a message by swapping case of all letters and replacing vowels \n    with the letter that appears two places ahead in the English alphabet.\n\n    Args:\n        message (str): The message to be encoded.\n\n    Returns:\n        str: The encoded message.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    \n    if not isinstance(message, str):\n        raise TypeError('Input must be a string')\n        \n    vowels = 'aeiouAEIOU'\n    encoded_msg = ''\n    \n    for char in message:\n        # Swap case of letters and replace vowels\n        if char.isalpha():\n            if char in vowels:\n                new_char = chr((ord(char) - ord('a') + 2) % 26 + ord('a')) if char.islower() else chr((ord(char) - ord('A') + 2) % 26 + ord('A'))\n            else:\n                new_char = char.swapcase()\n        # Keep non-letter characters as they are\n        else:\n            new_char = char\n            \n        encoded_msg += new_char\n        \n    return encoded_msg\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "\ndef remove_vowels(text):\n    \"\"\"\n    This function takes a string as input and returns the same string without vowels.\n\n    Args:\n        text (str): The string from which to remove vowels.\n\n    Returns:\n        str: The input string with all vowels removed.\n\n    Raises:\n        TypeError: If the argument is not a string.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"The argument must be a string.\")\n    \n    return \"\".join([char for char in text if char.lower() not in 'aeiou'])\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "\ndef fruit_distribution(fruit_string, total_fruits):\n    \"\"\"\n    This function calculates the number of mango fruits in a basket given \n    the string that represents the total number of apples and oranges \n    and an integer that represent the total number of the fruits in the basket.\n\n    Args:\n        fruit_string: A string representing the number of apples and oranges in the basket.\n        total_fruits: An integer representing the total number of fruits in the basket.\n\n    Returns:\n        The number of mango fruits in the basket.\n\n    Raises:\n        ValueError: If the fruit_string does not contain a valid representation \n                    of the number of apples and oranges.\n    \n    \"\"\"\n    # Split the string into words to get the numbers of apples and oranges\n    try:\n        fruits = fruit_string.split()\n        num_apples, num_oranges = int(fruits[0]), int(fruits[2])\n    except ValueError as e:\n        raise ValueError(\"Invalid input string\") from e\n    \n    # Calculate the number of mango fruits by subtracting the total number \n    # of apples and oranges from the total number of fruits in the basket.\n    num_mango = total_fruits - num_apples - num_oranges\n    \n    return num_mango\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "\ndef common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    Args:\n        l1: The first list of integers.\n        l2: The second list of integers.\n\n    Returns:\n        A sorted list of the unique common elements from both input lists.\n\n    Raises:\n        TypeError: If either of the inputs is not a list or contains non-integer values.\n    \"\"\"\n    # Check if inputs are lists and contain only integers\n    for i in [l1, l2]:\n        if type(i) != list:\n            raise TypeError(\"Both arguments must be of type 'list'.\")\n        elif not all(isinstance(j, int) for j in i):\n            raise TypeError(\"All elements in the lists must be integers.\")\n    \n    # Find common elements and return sorted unique values\n    return sorted(set(l1).intersection(l2))\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["SgmW", "wdIIZAXJqx", "sRbO", "mqbFo", "", "vZmyAs", "dajGeqFZ", "Jr", "Hv"], [1, 2, 3, 1]]]}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "\ndef sum_of_digits(n):\n    \"\"\"Calculate the sum of digits of a number.\n\n    Args:\n        n: The integer to calculate the sum of its digits.\n\n    Returns:\n        The sum of the digits of the input number.\n    \"\"\"\n    return sum(int(digit) for digit in str(n))\n\ndef is_prime(n):\n    \"\"\"Check if a number is prime.\n\n    Args:\n        n: The integer to check if it's a prime number.\n\n    Returns:\n        True if the input number is prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef largest_prime_sum(lst):\n    \"\"\"Find the sum of digits of the largest prime number in a list.\n\n    Args:\n        lst: The list of integers to search for the largest prime number.\n\n    Returns:\n        The sum of the digits of the largest prime number in the input list, or 0 if no prime numbers are found.\n    \"\"\"\n    primes = [x for x in lst if is_prime(x)]\n    return sum_of_digits(max(primes)) if primes else 0\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "\ndef unique(lst):\n    \"\"\"Return sorted unique elements in a list.\n\n    Args:\n        lst (list): The input list of integers.\n\n    Returns:\n        list: A new list containing the sorted unique elements from the input list.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the input list contains non-integer values.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    for i in lst:\n        if not isinstance(i, int):\n            raise ValueError(\"All elements of the input list must be integers.\")\n            \n    return sorted(set(lst))\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["a", "b", "b", "c", "d", "d"]]]}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "\ndef sort_third(lst):\n    \"\"\"This function takes a list lst and returns a new list where the elements at indices divisible by three are sorted.\n\n    Args:\n        lst (list): The input list to be processed.\n\n    Returns:\n        list: A new list with elements at indices divisible by three sorted.\n\n    Raises:\n        TypeError: If the input is not a list.\n    \"\"\"\n    \n    # Check if the input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list\")\n        \n    # Create a copy of the original list\n    sorted_list = lst[:]\n    \n    # Get elements at indices divisible by three and sort them\n    thirds = sorted([val for i, val in enumerate(lst) if i % 3 == 0])\n    \n    # Replace elements at indices divisible by three with the sorted ones\n    for i in range(len(sorted_list)):\n        if i % 3 == 0:\n            sorted_list[i] = thirds.pop(0)\n            \n    return sorted_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "\ndef minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The smallest sum of a sub-array in nums.\n\n    Raises:\n        ValueError: If the input is not a list or if it contains non-integer values.\n    \"\"\"\n    \n    # Checking if the input is valid\n    if not isinstance(nums, list):\n        raise ValueError(\"The input should be a list.\")\n    for num in nums:\n        if not isinstance(num, int):\n            raise ValueError(\"All elements of the list should be integers.\")\n    \n    # Initializing minimum sum to infinity and current sum to 0\n    min_sum = float('inf')\n    curr_sum = 0\n    \n    for num in nums:\n        # If adding the current number makes the current sum less than 0, then we start a new sub-array from this number\n        if curr_sum > 0:\n            curr_sum = num\n        else:\n            curr_sum += num\n        \n        # Updating minimum sum if necessary\n        min_sum = min(min_sum, curr_sum)\n    \n    return min_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "\ndef split_words(txt):\n    \"\"\"Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') =0, ord('b') = 1, ... ord('z') = 25.\n\n    Args:\n        txt (str): The input string to be split into words.\n\n    Returns:\n        list or int: If whitespaces or commas exist in the text, a list of words is returned. Otherwise, the number of lower-case letters with odd order in the alphabet is returned.\n\n    Raises:\n        ValueError: If input is not a string.\n    \"\"\"\n    \n    if not isinstance(txt, str):\n        raise ValueError(\"Input must be a string\")\n        \n    # Split on whitespace\n    words = txt.split()\n    if len(words) > 1:\n        return words\n    \n    # If no whitespaces exist, split on commas\n    words = txt.split(',')\n    if len(words) > 1:\n        return words\n        \n    # Count lower-case letters with odd order in the alphabet\n    count = 0\n    for char in txt:\n        if char.islower() and (ord(char) - ord('a')) % 2 == 1:\n            count += 1\n            \n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "\ndef odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, \n    returns a list where each element i is the number of odd elements in the\n    string i of the input.\n\n    Args:\n        lst: A list of strings, where each string contains only digits.\n\n    Returns:\n        A list of strings where each string explains how many odd numbers are \n        there in the corresponding indexed string of the input list.\n\n    Raises:\n        TypeError: If the input is not a list or if any element of the list is not a string.\n        ValueError: If any string contains non-digit characters.\n    \"\"\"\n    \n    # Checking if lst is a list and all elements are strings\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list.\")\n    for i in lst:\n        if not isinstance(i, str):\n            raise TypeError(\"All elements of the input list should be strings.\")\n    \n    # Checking if all characters in each string are digits\n    for i in lst:\n        if not i.isdigit():\n            raise ValueError(\"Each string should contain only digits.\")\n            \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum([1 for c in s if int(c) % 2 != 0])\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "\ndef sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n\n    Args:\n        n (int): The number up to which the sum will be calculated.\n\n    Returns:\n        int: The sum of all integers from 1 to n.\n\n    Raises:\n        TypeError: If input is not an integer.\n        ValueError: If input is less than 1.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    elif n < 1:\n        raise ValueError(\"Input must be greater than or equal to 1.\")\n    \n    return sum(range(1, n + 1))\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "\ndef add_elements(arr, k):\n    \"\"\"Given a non-empty array of integers arr and an integer k, \n       return the sum of the elements with at most two digits from the first k elements of arr.\n\n    Args:\n        arr: A list of integers.\n        k: An integer indicating how many elements to consider from the start of arr.\n\n    Returns:\n        The sum of the elements in arr with at most two digits, considering only the first k elements.\n\n    Raises:\n        ValueError: If k is not within the valid range (1 <= k <= len(arr)).\n        TypeError: If arr contains non-integer values or if k is not an integer.\n    \"\"\"\n    \n    # Checking if inputs are valid\n    if not all(isinstance(i, int) for i in arr):\n        raise TypeError(\"All elements of the array must be integers.\")\n    if not isinstance(k, int):\n        raise TypeError(\"The number of elements to consider must be an integer.\")\n    if k < 1 or k > len(arr):\n        raise ValueError(\"The number of elements to consider must be within 1 and the length of the array.\")\n    \n    # Calculating sum of elements with at most two digits\n    return sum(i for i in arr[:k] if i <= 99)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-100, -89, -77, -55, 900, -44, -22, -11], 7]]}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "\ndef sorted_list_sum(lst):\n    \"\"\"Deletes the strings that have odd lengths from a list of strings, \n    sorts the resulted list by length in ascending order, and returns it.\n\n    Args:\n        lst (List[str]): A list of strings.\n\n    Returns:\n        List[str]: The sorted list with even-length strings only.\n\n    Raises:\n        TypeError: If the input is not a list or if any element in the list is not a string.\n    \"\"\"\n    \n    # Checking if lst is a list and all elements are strings\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list.\")\n    for i in lst:\n        if not isinstance(i, str):\n            raise TypeError(\"All elements of the input list should be strings.\")\n    \n    # Filtering out odd-length strings and sorting by length and alphabetically\n    result = sorted([s for s in lst if len(s) % 2 == 0], key=lambda x: (len(x), x))\n    \n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "\ndef get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, returns a sorted list of the odd numbers in the Collatz sequence.\n\n    Args:\n        n: A positive integer.\n\n    Returns:\n        A sorted list of the odd numbers in the Collatz sequence for n.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if type(n) != int or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    \n    odd_collatz_numbers = sorted([i for i in collatz_sequence if i % 2 != 0])\n    \n    return odd_collatz_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "\ndef valid_date(date):\n    \"\"\"This function checks if a given date string is valid or not.\n\n    Args:\n        date (str): The date string to be checked in the format 'mm-dd-yyyy'.\n\n    Returns:\n        bool: True if the date is valid, False otherwise.\n\n    Raises:\n        ValueError: If the input is not a string or does not match the required format.\n    \"\"\"\n    \n    # Check if the input is a string\n    if not isinstance(date, str):\n        raise ValueError(\"The input must be a string.\")\n        \n    # Split the date into month, day and year\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    \n    # Check if the date is in correct format (mm-dd-yyyy)\n    if len(date.split('-')) != 3:\n        return False\n        \n    # Check if month, day and year are within valid range\n    if not 1 <= month <= 12 or not 1 <= day <= 31 or year < 0:\n        return False\n    \n    # Check for February with leap years\n    if month == 2:\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            if day > 29:\n                return False\n        elif day > 28:\n            return False\n    \n    # Check for months with 30 days\n    if month in [4, 6, 9, 11] and day > 30:\n        return False\n        \n    return True\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["02-29-2021"]]}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        str: The modified string.\n\n    Raises:\n        TypeError: If the input is not a string.\n        \n    Examples:\n        >>> fix_spaces(\"Example\") \n        'Example'\n        >>> fix_spaces(\"Example 1\") \n        'Example_1'\n        >>> fix_spaces(\" Example 2\") \n        '_Example_2'\n        >>> fix_spaces(\" Example  3\") \n        '_Example-3'\n    \"\"\"\n    \n    if not isinstance(text, str):\n        raise TypeError('Input must be a string')\n    \n    # Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # If there are more than 2 consecutive underscores, replace them with -\n    while '___' in text:\n        text = text.replace('___', '-')\n        \n    return text\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Hey    there!"]]}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "\ndef reverse_delete(s, c):\n    \"\"\"Deletes all characters in s that are equal to any character in c. \n       Checks if the result string is a palindrome.\n\n    Args:\n        s: The original string.\n        c: A string containing characters to be deleted from s.\n\n    Returns:\n        A tuple containing the resulting string and a boolean indicating whether it's a palindrome.\n\n    Raises:\n        TypeError: If either of the inputs is not a string.\n    \"\"\"\n    \n    # Check if both inputs are strings\n    if not all(isinstance(i, str) for i in [s, c]):\n        raise TypeError(\"Both arguments must be strings.\")\n        \n    # Delete characters from s that appear in c\n    result = ''.join([char for char in s if char not in c])\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return (result, is_palindrome)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "\ndef max_fill(grid, capacity):\n    \"\"\"Calculate the maximum number of times a bucket can be lowered to empty wells.\n\n    Args:\n        grid: A 2D list representing the layout of wells and their water levels.\n        capacity: An integer representing the capacity of each bucket.\n\n    Returns:\n        The maximum number of times a bucket can be lowered to empty wells.\n\n    Raises:\n        ValueError: If grid is not rectangular or if any element in grid is not 0 or 1.\n        TypeError: If grid is not a list of lists, or if capacity is not an integer.\n    \"\"\"\n    \n    # Checking the type and value constraints\n    if not all(isinstance(row, list) for row in grid):\n        raise ValueError(\"Grid must be a 2D list\")\n        \n    if not all(len(row) == len(grid[0]) for row in grid):\n        raise ValueError(\"All rows in the grid must have the same length\")\n    \n    if not isinstance(capacity, int):\n        raise TypeError(\"Capacity must be an integer\")\n        \n    if capacity < 1 or capacity > 10:\n        raise ValueError(\"Capacity must be between 1 and 10 inclusive\")\n        \n    if not all(cell == 0 or cell == 1 for row in grid for cell in row):\n        raise ValueError(\"All cells in the grid must be either 0 or 1\")\n    \n    # Calculating the maximum number of times a bucket can be lowered\n    max_fill = 0\n    for row in grid:\n        water = sum(row)\n        if water % capacity == 0:\n            max_fill += water // capacity\n        else:\n            max_fill += water // capacity + 1\n    \n    return max_fill\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "\ndef file_name_check(file_name):\n    \"\"\"Create a function which takes a string representing a file's name, and returns 'Yes' if the \n    file's name is valid, and returns 'No' otherwise.\n\n    Args:\n        file_name (str): The name of the file to be checked.\n\n    Returns:\n        str: 'Yes' if the file's name is valid, 'No' otherwise.\n\n    Raises:\n        TypeError: If the input argument is not a string.\n    \"\"\"\n    \n    # Check if the input is a string\n    if not isinstance(file_name, str):\n        raise TypeError(\"The input should be a string.\")\n        \n    # Split the file name into two parts at the dot\n    try:\n        name, extension = file_name.rsplit('.', 1)\n    except ValueError:\n        return 'No'\n    \n    # Check if there are more than three digits in the file's name\n    if sum(c.isdigit() for c in file_name) > 3:\n        return 'No'\n        \n    # Check if the substring before the dot starts with a letter from the latin alphabet\n    if not name[0].isalpha():\n        return 'No'\n    \n    # Check if the substring after the dot is one of these: ['txt', 'exe', 'dll']\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n        \n    return 'Yes'\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["all.exe.txt"]], "plus_fail_tests": [["alice.123.txt"]]}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "\ndef specialFilter(nums):\n    \"\"\"This function takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n\n    Args:\n        nums: An array of numbers.\n\n    Returns:\n        The count of elements in the array that meet the specified conditions.\n\n    Raises:\n        TypeError: If input is not a list or if any element of the list is not an integer.\n    \"\"\"\n    \n    # Checking if nums is a list and all elements are integers\n    if not isinstance(nums, list) or not all(isinstance(i, int) for i in nums):\n        raise TypeError(\"Input should be a list of integers\")\n        \n    count = 0\n    \n    # Iterating over each number in the array\n    for num in nums:\n        str_num = str(abs(num))  # Converting to string to get first and last digits\n        \n        # Checking if number is greater than 10, first digit is odd and last digit is odd\n        if num > 10 and int(str_num[0]) % 2 != 0 and int(str_num[-1]) % 2 != 0:\n            count += 1\n            \n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "\ndef planets_between(planet1, planet2):\n    \"\"\"Returns a tuple of all planets whose orbits are located between the orbit \n    of planet1 and the orbit of planet2, sorted by the proximity to the sun.\n\n    Args:\n        planet1: The name of the first planet as a string.\n        planet2: The name of the second planet as a string.\n\n    Returns:\n        A tuple containing all planets whose orbits are located between the orbit \n        of planet1 and the orbit of planet2, sorted by the proximity to the sun.\n        \n    Raises:\n        ValueError: If planet1 or planet2 are not correct planet names.\n    \"\"\"\n    \n    solar_system = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \n                   \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 not in solar_system or planet2 not in solar_system:\n        raise ValueError(\"Invalid planet name(s).\")\n        \n    index1 = solar_system.index(planet1)\n    index2 = solar_system.index(planet2)\n    \n    if index1 < index2:\n        return tuple(solar_system[index1+1 : index2])\n    else:\n        return tuple(solar_system[index2+1 : index1])\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "\ndef check_if_last_char_is_a_letter(txt):\n    \"\"\"\n    This function checks if the last character of a given string is an alphabetical \n    character and is not a part of a word.\n\n    Args:\n        txt (str): The input string to be checked.\n\n    Returns:\n        bool: True if the last character is an alphabetical character and it's not a part of a word, False otherwise.\n\n    Raises:\n        TypeError: If the provided argument is not a string.\n    \"\"\"\n    \n    # Checking if txt is a string\n    if not isinstance(txt, str):\n        raise TypeError(\"The input should be a string\")\n        \n    # Splitting the text into words and checking if last character of last word is alphabetical\n    return txt.split()[-1][-1].isalpha() if txt.split() else False\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["pUMPKIN PIE"]]}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "\ndef sum_squares(lst):\n    \"\"\"Calculate the sum of squares for each number in a list after rounding up to the nearest integer.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The sum of squared numbers in the given list, rounded and then squared.\n\n    Raises:\n        TypeError: If the input is not a list or if it contains non-numeric elements.\n    \"\"\"\n    \n    # Checking if the input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list\")\n        \n    # Checking if all elements in the list are numbers\n    for i in lst:\n        if not isinstance(i, (int, float)):\n            raise TypeError(\"All elements in the list should be numeric\")\n            \n    return sum([round(x)**2 for x in lst])\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1.4, 4.2, 0]]], "plus_fail_tests": [[[0, 3.3, 7.7, -2.2]]]}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "\ndef choose_num(x: int, y: int) -> int:\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    Args:\n        x: The first positive number.\n        y: The second positive number.\n\n    Returns:\n        The biggest even integer number in the range [x, y] inclusive or -1 if \n        there's no such number.\n\n    Raises:\n        ValueError: If either x or y is not a positive integer.\n    \"\"\"\n    # Check that both inputs are positive integers\n    if not (isinstance(x, int) and isinstance(y, int)) or x <= 0 or y <= 0:\n        raise ValueError(\"Both x and y must be positive integers.\")\n    \n    # If y is even, return it\n    if y % 2 == 0:\n        return y\n    \n    # Otherwise, if x is greater than y, there's no number in the range\n    elif x > y:\n        return -1\n    \n    # Otherwise, the biggest even number is one less than y\n    else:\n        return y - 1\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[13, 12]], "plus_fail_tests": [[100, 6]]}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "\nfrom typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        A list of rolling maximum elements.\n\n    Raises:\n        TypeError: If input is not a list or if it contains non-integer values.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # Check if input is a list of integers\n    if not isinstance(numbers, list) or not all(isinstance(i, int) for i in numbers):\n        raise TypeError(\"Input must be a list of integers.\")\n    \n    max_list = []\n    current_max = None\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        max_list.append(current_max)\n        \n    return max_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n        numbers: A list of floating point numbers.\n        threshold: The maximum difference between two numbers for them to be considered 'close'.\n\n    Returns:\n        True if there are two numbers in the list that are closer to each other than the \n        given threshold, False otherwise.\n\n    Raises:\n        ValueError: If the input list is empty or if the threshold is not a positive number.\n    \"\"\"\n    \n    # Check for invalid inputs\n    if len(numbers) == 0:\n        raise ValueError(\"The input list cannot be empty.\")\n    if threshold <= 0:\n        raise ValueError(\"Threshold must be a positive number.\")\n        \n    # Sort the numbers in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Check for close elements\n    for i in range(len(sorted_numbers)-1):\n        if abs(sorted_numbers[i] - sorted_numbers[i+1]) <= threshold:\n            return True\n            \n    return False\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1.0, 2.0, 3.0, 4.0, 5.0], 1.0]]}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "\ndef by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    Args:\n        arr: An array of integers.\n\n    Returns:\n        A list of strings representing the sorted, reversed and replaced digits.\n\n    Raises:\n        TypeError: If the input is not a list or if it contains non-integer elements.\n    \"\"\"\n    \n    # Checking if arr is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"The input should be a list.\")\n        \n    # Filtering out integers between 1 and 9 inclusive\n    filtered_arr = [i for i in arr if isinstance(i, int) and 1 <= i <= 9]\n    \n    # Sorting the array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reversing the array\n    reversed_arr = list(reversed(sorted_arr))\n    \n    # Converting each digit to its corresponding name\n    num2words = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}\n    replaced_arr = [num2words[i] for i in reversed_arr]\n    \n    return replaced_arr\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "\nfrom typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"Filter an input list of strings only for ones that contain given substring.\n\n    Args:\n        strings: A list of strings to be filtered.\n        substring: The substring to filter the strings by.\n\n    Returns:\n        A new list containing only those strings from the input list that contain the specified substring.\n\n    Raises:\n        TypeError: If 'strings' is not a list or if 'substring' is not a string.\n    \"\"\"\n    # Checking if inputs are of correct type\n    if not isinstance(strings, list) or not all(isinstance(s, str) for s in strings):\n        raise TypeError(\"'strings' must be a list of strings.\")\n    if not isinstance(substring, str):\n        raise TypeError(\"'substring' must be a string.\")\n    \n    # Filtering the input list\n    filtered_list = [s for s in strings if substring in s]\n    \n    return filtered_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "\ndef double_the_difference(lst):\n    \"\"\"Given a list of numbers, return the sum of squares of the odd integers in the list. \n       Ignore negative numbers and non-integer numbers.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The sum of squares of the odd integers in the list.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list contains non-integer or negative numbers.\n    \"\"\"\n    \n    # Check if lst is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list\")\n        \n    # Initialize sum to 0\n    total = 0\n    \n    for num in lst:\n        # Check if the number is an integer and odd\n        if isinstance(num, int) and num % 2 != 0:\n            total += num ** 2\n        elif not isinstance(num, int):\n            raise ValueError(\"List should only contain integers\")\n        else:\n            continue\n            \n    return total\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[0.1, 0.2, 0.3]]], "plus_fail_tests": [[[-5, 7, 9]]]}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\n    Args:\n        number (int): A positive integer between 1 and 1000 inclusive.\n\n    Returns:\n        str: The roman numeral equivalent of the input number in lowercase.\n\n    Raises:\n        ValueError: If the input number is not a positive integer or if it's outside the range 1 to 1000.\n        \n    Examples:\n    >>> int_to_mini_roman(19)\n    'xix'\n    >>> int_to_mini_roman(152)\n    'clii'\n    >>> int_to_mini_roman(426)\n    'cdxxvi'\n    \"\"\"\n    if not isinstance(number, int) or number < 1 or number > 1000:\n        raise ValueError(\"Input must be a positive integer between 1 and 1000.\")\n    \n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n        ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n        ]\n    roman_num = ''\n    i = 0\n    while  number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num.lower()\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "\ndef find_max(words):\n    \"\"\"Find the word with maximum number of unique characters. If multiple strings have \n    maximum number of unique characters, return the one which comes first in lexicographical order.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The word with maximum number of unique characters or the first string if there are no words.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list contains non-string elements.\n    \"\"\"\n    \n    # Checking if the input is a list\n    if not isinstance(words, list):\n        raise TypeError(\"Input should be a list of strings\")\n        \n    # Checking if all elements in the list are strings\n    for word in words:\n        if not isinstance(word, str):\n            raise ValueError(\"All elements in the list should be strings\")\n    \n    # Initializing max_unique and max_word to keep track of maximum unique characters and corresponding word\n    max_unique = 0\n    max_word = \"\"\n    \n    for word in words:\n        # Finding number of unique characters in each word\n        num_unique = len(set(word))\n        \n        if num_unique > max_unique or (num_unique == max_unique and word < max_word):\n            max_unique = num_unique\n            max_word = word\n            \n    return max_word\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "\ndef do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator and operand. The first list has basic algebra operations, \n    and the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    Args:\n        operator: A list of algebraic operators.\n        operand: A list of non-negative integers.\n\n    Returns:\n        The result of the evaluated algebraic expression.\n\n    Raises:\n        ValueError: If the length of operator list is not equal to the length of \n                    operand list minus one.\n    \n    \"\"\"\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The length of operator list must be equal to the \"\n                         \"length of operand list minus one.\")\n        \n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += ' ' + operator[i] + ' ' + str(operand[i+1])\n    \n    return eval(expression)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "\ndef unique_digits(numbers):\n    \"\"\"Given a list of positive integers numbers, returns a sorted list of all \n    elements that has no even digit.\n\n    Args:\n        numbers: A list of positive integers.\n\n    Returns:\n        A sorted list of all elements in the input list that has no even digits.\n\n    Raises:\n        ValueError: If any element in the input list is not a positive integer.\n    \"\"\"\n    \n    # Check if all numbers are positive integers\n    for num in numbers:\n        if not isinstance(num, int) or num <= 0:\n            raise ValueError(\"All elements in the list must be positive integers.\")\n            \n    # Filter out numbers with even digits and sort the result\n    return sorted([num for num in numbers if all(digit % 2 == 1 for digit in map(int, str(num)))])\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/6": [{"task_id": "HumanEval/6", "solution": "\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"This function takes a string of multiple groups for nested parentheses separated by spaces \n    and returns the deepest level of nesting for each group.\n\n    Args:\n        paren_string: A string represented multiple groups for nested parentheses separated by spaces.\n\n    Returns:\n        A list of integers where each integer represents the maximum depth of nesting in a group.\n\n    Raises:\n        ValueError: If the input string contains any character other than '(' and ')'.\n    \"\"\"\n    \n    # Check if the string only contains parentheses\n    for char in paren_string:\n        if char != \"(\" and char != \")\":\n            raise ValueError(\"Input string should only contain parentheses.\")\n            \n    max_depths = []\n    groups = paren_string.split()  # Split the string into groups\n    \n    for group in groups:\n        current_depth = 0\n        max_depth = 0\n        \n        for char in group:\n            if char == \"(\":\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == \")\":\n                current_depth -= 1\n                \n        max_depths.append(max_depth)\n        \n    return max_depths\n", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "\ndef can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \n    Args:\n        arr: A list of integers in non-decreasing order.\n\n    Returns:\n        The largest index of an element which is not greater than or equal to the \n        element immediately preceding it. If no such element exists then return -1.\n\n    Raises:\n        TypeError: If arr is not a list.\n        ValueError: If arr contains non-integer values.\n    \"\"\"\n    \n    # Check if arr is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input should be a list.\")\n        \n    # Check if all elements in arr are integers\n    for i in arr:\n        if not isinstance(i, int):\n            raise ValueError(\"All elements in the input list should be integers.\")\n    \n    # Iterate over the array from right to left\n    for i in range(len(arr)-1, 0, -1):\n        # If current element is less than previous one return its index\n        if arr[i] < arr[i-1]:\n            return i\n    \n    # If no such element exists then return -1\n    return -1\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[37.45846213316932, -21.8131802318007, -18.630055685163583, -76.49298700358514, -63.655488885630994, 81.75342869524977, 96.86306070463999, 77.21191831561089, 22.028951203200748, -54.83341431889768]]]}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Separate groups of nested parentheses into separate strings.\n\n    Args:\n        paren_string: A string containing multiple groups of nested parentheses.\n\n    Returns:\n        A list of strings, where each string is a group of balanced and properly nested parentheses.\n\n    Raises:\n        ValueError: If the input string contains unbalanced or improperly nested parentheses.\n    \"\"\"\n    paren_string = paren_string.replace(\" \", \"\")  # Remove spaces from the string\n    groups = []\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            group = ''\n            while stack and stack[-1] != '(':\n                group = stack.pop() + group\n            if not stack:  # If the stack is empty, there's a mismatching parenthesis\n                raise ValueError(\"Unbalanced or improperly nested parentheses\")\n            stack.pop()  # Remove the opening bracket\n            groups.append('(' + group + ')')\n    if stack:  # If there are still items in the stack, there's a mismatching parenthesis\n        raise ValueError(\"Unbalanced or improperly nested parentheses\")\n    return groups\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["(())"]]}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "\nfrom typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"For a given list of integers, return a tuple consisting of a sum \n       and a product of all the integers in a list. Empty sum should be equal to 0 \n       and empty product should be equal to 1.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        A tuple where the first element is the sum of all elements in the input list, \n        and the second element is the product of all elements in the input list.\n\n    Raises:\n        TypeError: If the input is not a list or if it contains non-integer values.\n    \"\"\"\n    # Check that the input is a list of integers\n    if not isinstance(numbers, list) or not all(isinstance(i, int) for i in numbers):\n        raise TypeError(\"Input must be a list of integers.\")\n    \n    # Calculate sum and product\n    total_sum = sum(numbers)\n    total_product = 1\n    for num in numbers:\n        total_product *= num\n        \n    return (total_sum, total_product)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "\ndef eat(number: int, need: int, remaining: int) -> list[int]:\n    \"\"\"Calculate the total number of eaten carrots after meals and the remaining carrots.\n\n    Args:\n        number: The number of carrots that have been eaten.\n        need: The number of carrots needed to be eaten.\n        remaining: The number of remaining carrots in stock.\n\n    Returns:\n        A list containing the total number of eaten carrots after meals and the remaining carrots.\n\n    Raises:\n        ValueError: If any of the parameters is not an integer or if they are out of range.\n    \"\"\"\n    \n    # Checking if all inputs are integers\n    if not all(isinstance(i, int) for i in [number, need, remaining]):\n        raise ValueError(\"All input values must be integers.\")\n        \n    # Checking if all inputs are within the specified range\n    if not all(0 <= i <= 1000 for i in [number, need, remaining]):\n        raise ValueError(\"All input values must be between 0 and 1000 inclusive.\")\n    \n    total_eaten = number + min(need, remaining)\n    remaining -= min(need, remaining)\n    \n    if remaining < 0:\n        remaining = 0\n        \n    return [total_eaten, remaining]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "\ndef is_nested(brackets):\n    \"\"\"This function takes a string of brackets as input and returns True if there is at least one nested bracket in the sequence.\n\n    Args:\n        brackets (str): A string containing only square brackets.\n\n    Returns:\n        bool: True if there is at least one valid subsequence with a nested bracket, False otherwise.\n\n    Raises:\n        ValueError: If the input string contains any character other than square brackets.\n    \"\"\"\n    \n    # Check for invalid characters in the string\n    if not all(char in '[]' for char in brackets):\n        raise ValueError(\"Input string can only contain square brackets.\")\n        \n    stack = []\n    for bracket in brackets:\n        if bracket == '[':\n            # Push opening brackets onto the stack\n            stack.append(bracket)\n        elif bracket == ']':\n            # If there is a closing bracket and no opening brackets on the stack, return False\n            if not stack:\n                return False\n            else:\n                # Pop the last opening bracket from the stack\n                stack.pop()\n                \n    # If there are any remaining opening brackets on the stack, return True\n    return bool(stack)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "\ndef solve(s):\n    \"\"\"This function takes a string s as input and returns a new string where each letter is reversed in case \n    (from lower to upper or vice versa) and non-letter characters are kept as they are. If the string contains no letters, \n    it will return the reverse of the string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        A new string where each letter is reversed in case (from lower to upper or vice versa) and non-letter characters are kept as they are. \n        If the string contains no letters, it will return the reverse of the string.\n\n    Raises:\n        TypeError: If s is not a string.\n    \"\"\"\n    \n    # Check if input is a string\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n        \n    # Reverse the case of each letter and keep non-letter characters as they are\n    new_string = ''.join([c.upper() if c.islower() else c.lower() if c.isalpha() else c for c in s])\n    \n    # If no letters were found, reverse the string\n    if not any(c.isalpha() for c in s):\n        new_string = s[::-1]\n        \n    return new_string\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "\ndef right_angle_triangle(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle, this function returns True if the \n    triangle is right-angled (i.e., one angle is right or 90 degrees), and False otherwise.\n\n    Args:\n        a: The length of side a in the triangle.\n        b: The length of side b in the triangle.\n        c: The length of side c in the triangle.\n\n    Returns:\n        True if the triangle is right-angled, False otherwise.\n\n    Raises:\n        ValueError: If any of the lengths are less than or equal to zero.\n    \"\"\"\n    \n    # Check for invalid inputs\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"The length of each side must be greater than 0.\")\n        \n    # Sort the sides so that 'c' is the hypotenuse (longest side)\n    a, b, c = sorted([a, b, c])\n    \n    # Check if triangle is right-angled using Pythagorean theorem\n    return abs(a**2 + b**2 - c**2) < 1e-9  # Use a small tolerance for floating point errors\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "\ndef x_or_y(n, x, y):\n    \"\"\"A simple program which returns the value of x if n is a prime number \n    and returns the value of y otherwise.\n\n    Args:\n        n: The number to check for primality.\n        x: The first value to return.\n        y: The second value to return.\n\n    Returns:\n        If n is a prime number, returns x. Otherwise, returns y.\n\n    Raises:\n        TypeError: If n, x or y are not integers.\n        ValueError: If n is less than 2 (as there are no prime numbers less than 2).\n    \"\"\"\n    \n    # Check if inputs are valid\n    if not all(isinstance(i, int) for i in [n, x, y]):\n        raise TypeError(\"All arguments must be integers.\")\n    if n < 2:\n        raise ValueError(\"There are no prime numbers less than 2.\")\n    \n    # Check if n is a prime number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return y\n    return x\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 2, 0]], "plus_fail_tests": []}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "\ndef decimal_to_binary(decimal):\n    \"\"\"Converts a given decimal number to binary format.\n\n    Args:\n        decimal (int): The decimal number to be converted.\n\n    Returns:\n        str: A string representing the binary equivalent of the input decimal, \n             with 'db' at the beginning and end.\n\n    Raises:\n        TypeError: If the input is not an integer.\n    \"\"\"\n    \n    if not isinstance(decimal, int):\n        raise TypeError(\"The input must be an integer.\")\n        \n    binary = bin(decimal).replace(\"0b\", \"\")\n    return 'db' + binary + 'db'\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "\ndef car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars moving in opposite directions on a straight line.\n\n    Args:\n        n: The number of cars in each set.\n\n    Returns:\n        The total number of collisions that would occur if the cars kept moving at the same speed and did not stop due to collisions.\n\n    Raises:\n        ValueError: If the input is less than 1 or not an integer.\n    \"\"\"\n    # Check for valid input\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Since each car from one set collides with every car from the other set, \n    # the total number of collisions would be the product of the two sets.\n    return n * n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "\ndef fib4(n: int) -> int:\n    \"\"\"Computes the n-th element of the fib4 number sequence.\n\n    The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n\n    Args:\n        n: The index of the element in the sequence.\n\n    Returns:\n        The n-th element of the fib4 number sequence.\n\n    Raises:\n        ValueError: If n is less than 0.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n    \n    # Initialize base cases\n    fib_sequence = [0, 0, 2, 0]\n    \n    # Compute the n-th element of the sequence\n    for i in range(4, n + 1):\n        fib_sequence.append(fib_sequence[i - 1] + fib_sequence[i - 2] + fib_sequence[i - 3] + fib_sequence[i - 4])\n    \n    return fib_sequence[n]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "\ndef is_palindrome(text: str) -> bool:\n    \"\"\"Checks if given string is a palindrome.\n\n    Args:\n        text: The string to check.\n\n    Returns:\n        True if the string is a palindrome, False otherwise.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError('Input must be a string')\n    \n    return text == text[::-1]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n\n    Args:\n        n (int): The number of digits in the positive integers.\n\n    Returns:\n        int: The count of the numbers of n-digit positive integers that start or end with 1.\n\n    Raises:\n        ValueError: If the input is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n    \n    return 2 * (10 ** (n-1)) - 10 ** (n//2 - 1)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "\ndef iscube(a):\n    \"\"\"Checks if a number is a cube of some integer.\n\n    Args:\n        a: The integer to check.\n\n    Returns:\n        True if the number is a cube, False otherwise.\n\n    Raises:\n        No exceptions are raised in this function.\n    \"\"\"\n    return round(a ** (1./3)) ** 3 == a\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[-1]], "plus_fail_tests": []}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "\ndef rounded_avg(n: int, m: int) -> str:\n    \"\"\"Computes the average of integers from n through m (inclusive), \n    rounds to nearest integer, and converts that to binary. If n > m, returns -1.\n\n    Args:\n        n: The first positive integer.\n        m: The second positive integer.\n\n    Returns:\n        A string representing the binary representation of the rounded average \n        if n <= m, otherwise -1.\n\n    Raises:\n        ValueError: If either n or m is not a positive integer.\n    \"\"\"\n    # Check that both inputs are positive integers\n    if not (isinstance(n, int) and isinstance(m, int) and n > 0 and m > 0):\n        raise ValueError(\"Both inputs must be positive integers.\")\n    \n    # If n > m, return -1\n    if n > m:\n        return -1\n    \n    # Compute the average of the integers from n through m (inclusive)\n    avg = sum(range(n, m + 1)) / ((m - n) + 1)\n    \n    # Round to nearest integer and convert to binary\n    rounded_avg_bin = bin(round(avg))\n    \n    return rounded_avg_bin\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "\ndef get_max_triples(n):\n    \"\"\"\n    This function generates an array of length n where each element is i^2 - i + 1 for 1 <= i <= n.\n    It then counts the number of triples (a[i], a[j], a[k]) such that i < j < k and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Args:\n        n: A positive integer representing the length of the array to be generated.\n\n    Returns:\n        The number of valid triples in the form of (a[i], a[j], a[k]) where i < j < k and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    \n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n        \n    # Generate the array\n    arr = [i**2 - i + 1 for i in range(1, n+1)]\n    \n    # Initialize counter\n    count = 0\n    \n    # Iterate over all possible triples\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if (arr[i] + arr[j] + arr[k]) % 3 == 0:\n                    count += 1\n    \n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "\ndef solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n\n    Args:\n        N (int): A positive integer between 0 and 10000.\n\n    Returns:\n        str: The binary representation of the sum of the digits in N.\n\n    Raises:\n        ValueError: If N is not a positive integer or if it's greater than 10000.\n    \"\"\"\n    # Checking constraints\n    if type(N) != int or N < 0 or N > 10000:\n        raise ValueError(\"Input must be a positive integer between 0 and 10000.\")\n    \n    # Calculating sum of digits in binary\n    digit_sum = sum([int(digit) for digit in str(N)])\n    \n    return bin(digit_sum)[2:]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "\ndef strange_sort_list(lst):\n    \"\"\"Given a list of integers, returns the list sorted in a 'strange' order. \n    Strange sorting is when you start with the minimum value, then maximum of the remaining integers, \n    then minimum and so on.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        list: The sorted list in 'strange' order.\n\n    Raises:\n        TypeError: If the input is not a list or if it contains non-integer elements.\n    \"\"\"\n    \n    # Checking if lst is a list and all its elements are integers\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list.\")\n    for i in lst:\n        if not isinstance(i, int):\n            raise TypeError(\"All elements of the input list should be integers.\")\n    \n    # Sorting the list in ascending order\n    sorted_lst = sorted(lst)\n    \n    result = []\n    while len(sorted_lst) > 0:\n        # Appending minimum element\n        result.append(sorted_lst[0])\n        sorted_lst.pop(0)\n        \n        if len(sorted_lst) > 0:\n            # Appending maximum element\n            result.append(sorted_lst[-1])\n            sorted_lst.pop(-1)\n    \n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "\ndef strlen(string: str) -> int:\n    \"\"\"Return length of given string.\n\n    Args:\n        string: The input string whose length is to be calculated.\n\n    Returns:\n        An integer representing the length of the input string.\n\n    Raises:\n        TypeError: If the input parameter is not a string.\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError('The input must be a string')\n    \n    return len(string)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "\ndef add_even_elements_at_odd_indices(lst):\n    \"\"\"Given a non-empty list of integers lst, returns the sum of even elements that are at odd indices.\n\n    Args:\n        lst: A list of integers.\n\n    Returns:\n        The sum of even elements at odd indices in the list.\n\n    Raises:\n        ValueError: If the input is not a list or if it contains non-integer values.\n    \"\"\"\n    \n    # Checking if lst is a list and if all its elements are integers\n    if not isinstance(lst, list) or not all(isinstance(i, int) for i in lst):\n        raise ValueError(\"Input should be a non-empty list of integers\")\n    \n    # Checking if the list is empty\n    if len(lst) == 0:\n        return 0\n    \n    # Adding up even elements at odd indices\n    result = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            result += lst[i]\n            \n    return result\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "\ndef triangle_area(a, b, c):\n    \"\"\"Calculate the area of a triangle given its three sides.\n\n    Args:\n        a: The length of side a.\n        b: The length of side b.\n        c: The length of side c.\n\n    Returns:\n        The area of the triangle if it is valid, -1 otherwise.\n\n    Raises:\n        TypeError: If any of the parameters are not numbers.\n        ValueError: If any of the parameters are negative or zero.\n    \"\"\"\n    \n    # Checking if all inputs are positive numbers\n    for i in [a, b, c]:\n        if not isinstance(i, (int, float)) or i <= 0:\n            raise TypeError(\"All sides must be positive numbers\")\n            \n    # Checking if the triangle inequality holds\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    \n    # Calculating semi-perimeter\n    s = (a + b + c) / 2\n    \n    # Using Heron's formula to calculate the area\n    area = round((s * (s - a) * (s - b) * (s - c)) ** 0.5, 2)\n    \n    return area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "\nfrom typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings:  # If the list is empty, return None\n        return None\n\n    longest_string = strings[0]  # Assume the first string is the longest\n    for string in strings:  # Iterate over each string in the list\n        if len(string) > len(longest_string):  # If this string is longer than the current longest\n            longest_string = string  # Update the longest string\n\n    return longest_string  # Return the longest string found\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "\ndef prime_length(string):\n    \"\"\"Check if the length of a string is a prime number.\n\n    Args:\n        string (str): The input string to check its length.\n\n    Returns:\n        bool: True if the length of the string is a prime number, False otherwise.\n\n    Raises:\n        TypeError: If the input parameter is not a string.\n    \"\"\"\n    \n    # Check if the input is a string\n    if not isinstance(string, str):\n        raise TypeError(\"The input must be a string.\")\n        \n    # Get the length of the string\n    n = len(string)\n    \n    # If the length is less than 2, it's not prime\n    if n < 2:\n        return False\n    \n    # Check for factors up to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n            \n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "\ndef modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    Args:\n        n: The exponent for the base 2.\n        p: The modulus to be used in the calculation.\n\n    Returns:\n        The result of 2^n modulo p.\n\n    Raises:\n        ValueError: If either n or p is less than zero.\n\n    >>> modp(3, 5)\n    3\n    >>> modp(101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 0 or p < 0:\n        raise ValueError(\"Both n and p must be non-negative.\")\n    return pow(2, n, p)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "\ndef largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n: The input integer for which we need to find the largest divisor.\n\n    Returns:\n        The largest divisor of n that is less than n.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "\ndef triples_sum_to_zero(lst):\n    \"\"\"\n    This function takes a list of integers as an input. \n    It returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: True if there are three distinct elements in the list that sum to zero, False otherwise.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list contains less than 3 elements.\n    \"\"\"\n    \n    # Checking if the input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"The input should be a list.\")\n        \n    # Checking if the list has at least three elements\n    if len(lst) < 3:\n        raise ValueError(\"The list should have at least three elements.\")\n    \n    # Sorting the list in ascending order\n    lst.sort()\n    \n    for i in range(len(lst)-2):\n        left = i + 1\n        right = len(lst) - 1\n        \n        while left < right:\n            if lst[i] + lst[left] + lst[right] == 0:\n                return True\n            elif lst[i] + lst[left] + lst[right] < 0:\n                left += 1\n            else:\n                right -= 1\n                \n    return False\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1]]], "plus_fail_tests": [[[-2, -2]]]}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "\ndef hex_key(num):\n    \"\"\"Counts the number of hexadecimal digits in a string that are primes.\n\n    Args:\n        num: A string representing a hexadecimal number.\n\n    Returns:\n        The count of prime hexadecimal digits in the input string.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    \n    if not isinstance(num, str):\n        raise TypeError('Input must be a string')\n        \n    primes = ['2', '3', '5', '7', 'B', 'D']  # hexadecimal digits that are prime\n    count = 0\n    \n    for digit in num:\n        if digit.upper() in primes:\n            count += 1\n            \n    return count\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[]]], "plus_fail_tests": [[{}]]}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "\ndef median(lst):\n    \"\"\"Return the median of elements in the list lst.\n\n    Args:\n        lst: A list of numbers.\n\n    Returns:\n        The median value of the list. If the length of the list is even, \n        the average of the two middle values will be returned.\n\n    Raises:\n        TypeError: If the input is not a list or if it contains non-numeric elements.\n        ValueError: If the input list is empty.\n    \"\"\"\n    # Check that lst is a list and is not empty\n    if not isinstance(lst, list) or len(lst) == 0:\n        raise TypeError(\"Input must be a non-empty list\")\n    \n    # Check that all elements in the list are numbers\n    for i in lst:\n        if not isinstance(i, (int, float)):\n            raise TypeError(\"All elements in the list must be numeric\")\n            \n    # Sort the list\n    lst.sort()\n    \n    # Calculate the median\n    n = len(lst)\n    mid = n // 2\n    if n % 2 == 0:\n        return (lst[mid - 1] + lst[mid]) / 2\n    else:\n        return lst[mid]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"Return the greatest common divisor of two integers a and b.\n\n    Args:\n        a: The first integer.\n        b: The second integer.\n\n    Returns:\n        The greatest common divisor of a and b.\n\n    Raises:\n        ValueError: If either a or b is not an integer.\n        ZeroDivisionError: If both a and b are zero.\n    \"\"\"\n    if not all(isinstance(i, int) for i in (a, b)):\n        raise ValueError(\"Both inputs must be integers.\")\n    \n    if a == 0 and b == 0:\n        raise ZeroDivisionError(\"At least one of the inputs should be non-zero.\")\n        \n    while b != 0:\n        a, b = b, a % b\n    return abs(a)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "\nfrom typing import List\n\ndef all_prefixes(input_string: str) -> List[str]:\n    \"\"\"Return list of all prefixes from shortest to longest of the input string.\n\n    Args:\n        input_string: The string for which we want to find all its prefixes.\n\n    Returns:\n        A list of all prefixes of the input string, sorted by length in ascending order.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError('The input must be a string')\n    \n    return [input_string[:i] for i in range(1, len(input_string) + 1)]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/22": [{"task_id": "HumanEval/22", "solution": "\nfrom typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers.\n\n    Args:\n        values: A list of any python values.\n\n    Returns:\n        A list of integers from the input list.\n\n    Raises:\n        TypeError: If the input is not a list.\n    \"\"\"\n    if not isinstance(values, list):\n        raise TypeError('The input must be a list')\n    \n    return [value for value in values if isinstance(value, int)]\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[true, false, null, 0, -10, "test", [], {}, 3.14]]]}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "\ndef is_simple_power(x: int, n: int) -> bool:\n    \"\"\"Checks if a number x is a simple power of n.\n\n    Args:\n        x: The number to check.\n        n: The base number.\n\n    Returns:\n        True if x is a simple power of n, False otherwise.\n\n    Raises:\n        ValueError: If x or n are less than 1.\n    \"\"\"\n    if x < 1 or n < 1:\n        raise ValueError(\"Both x and n must be greater than 0.\")\n    \n    while x % n == 0:\n        x /= n\n        \n    return x == 1\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 1]], "plus_fail_tests": [[82, 1]]}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "\ndef encode_cyclic(s: str) -> str:\n    \"\"\"Encodes a string by cycling groups of three characters.\n\n    Args:\n        s: The string to be encoded.\n\n    Returns:\n        The encoded string.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    \n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    \n    return \"\".join(groups)\n\ndef decode_cyclic(s: str) -> str:\n    \"\"\"Decodes a string that was encoded with the encode_cyclic function.\n\n    Args:\n        s: The string to be decoded.\n\n    Returns:\n        The decoded string.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    \n    # reverse cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    \n    return \"\".join(groups)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "\nfrom typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors.\n    \n    Args:\n        n: The integer to be factorized.\n        \n    Returns:\n        A list of prime factors of the input integer, sorted from smallest to largest.\n        \n    Raises:\n        ValueError: If the input is not a positive integer.\n    \"\"\"\n    \n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    factors = []\n    i = 2  # Start from smallest prime number\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n            \n    if n > 1:\n        factors.append(n)\n        \n    return factors\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n\n    Args:\n        n (int): The number to check for primality.\n\n    Returns:\n        bool: True if the number is prime, False otherwise.\n\n    Raises:\n        TypeError: If the input is not an integer.\n        ValueError: If the input is less than 2.\n    \"\"\"\n    # Check that n is a positive integer\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    elif n < 2:\n        raise ValueError(\"Input must be greater than or equal to 2.\")\n    \n    # Check for factors up to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n            \n    return True\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": []}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "\ndef count_boredoms(s):\n    \"\"\"Count the number of boredoms in a string.\n\n    A boredom is defined as any sentence that starts with the word \"I\". \n    Sentences are delimited by '.', '?' or '!'.\n\n    Args:\n        s: The input string to be checked for boredoms.\n\n    Returns:\n        An integer representing the number of boredoms in the string.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    \n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string.\")\n        \n    # Split the string into sentences based on '.', '?', and '!'\n    sentences = [sentence.strip() for sentence in re.split('[.!?]', s) if sentence]\n    \n    # Count the number of sentences that start with \"I\"\n    boredoms = sum(1 for sentence in sentences if sentence.startswith(\"I\"))\n    \n    return boredoms\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "\ndef circular_shift(x: int, shift: int) -> str:\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift \n    and return the result as a string. If shift > number of digits, return digits reversed.\n\n    Args:\n        x (int): The integer to be shifted.\n        shift (int): The amount to shift x.\n\n    Returns:\n        str: The circularly shifted integer as a string.\n\n    Raises:\n        TypeError: If x or shift is not an integer.\n        ValueError: If x or shift is negative.\n    \"\"\"\n    # Check if inputs are integers\n    if not all(isinstance(i, int) for i in [x, shift]):\n        raise TypeError(\"Both x and shift must be integers.\")\n    \n    # Check if inputs are non-negative\n    if any(i < 0 for i in [x, shift]):\n        raise ValueError(\"Both x and shift must be non-negative.\")\n        \n    str_x = str(x)  # Convert integer to string\n    len_str_x = len(str_x)  # Get the length of the string\n    \n    if shift > len_str_x:  # If shift is greater than number of digits, reverse the digits\n        return str_x[::-1]\n    else:  # Otherwise, perform circular shift\n        return str_x[-shift:] + str_x[:-shift]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "\ndef derivative(coefficients: list) -> list:\n    \"\"\"Calculate the derivative of a polynomial represented by coefficients.\n\n    Args:\n        coefficients: A list of coefficients where index represents power \n                       and value at that index represents coefficient for x^index.\n\n    Returns:\n        The derivative of the polynomial as a list of coefficients.\n\n    Raises:\n        TypeError: If input is not a list.\n        ValueError: If any element in the list is not an integer or float.\n    \n    Examples:\n        >>> derivative([3, 1, 2, 4, 5])\n        [1, 4, 12, 20]\n        >>> derivative([1, 2, 3])\n        [2, 6]\n    \"\"\"\n    \n    # Check if input is a list\n    if not isinstance(coefficients, list):\n        raise TypeError(\"Input should be a list\")\n    \n    # Check if all elements in the list are integers or floats\n    for i in coefficients:\n        if not isinstance(i, (int, float)):\n            raise ValueError(\"All elements in the list should be integers or floats\")\n            \n    derivative_coefficients = [i*val for i, val in enumerate(coefficients)][1:]\n    \n    return derivative_coefficients\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"Check if two words have the same characters.\n\n    Args:\n        s0: The first word to compare.\n        s1: The second word to compare.\n\n    Returns:\n        True if both words contain exactly the same characters, False otherwise.\n\n    Raises:\n        TypeError: If either of the inputs is not a string.\n    \"\"\"\n    # Check that both inputs are strings\n    if not all(isinstance(s, str) for s in [s0, s1]):\n        raise TypeError('Both arguments must be strings')\n    \n    return sorted(s0) == sorted(s1)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["aaabbbccc", "abbabcbc"]]}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "\ndef add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y.\n\n    Args:\n        x: The first number to be added.\n        y: The second number to be added.\n\n    Returns:\n        The sum of the two input numbers.\n\n    Raises:\n        TypeError: If either x or y is not an integer.\n    \"\"\"\n    if not all(isinstance(i, int) for i in (x, y)):\n        raise TypeError('Both arguments must be integers')\n    \n    return x + y\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "\ndef count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of uppercase vowels at even indices.\n\n    Raises:\n        TypeError: If the argument is not a string.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError('The argument must be a string')\n    \n    count = 0\n    for i in range(len(s)):\n        # Check if index is even and character is an uppercase vowel\n        if i % 2 == 0 and s[i] in 'AEIOU':\n            count += 1\n            \n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "\ndef get_positive(lst):\n    \"\"\"Return only positive numbers in the list.\n\n    Args:\n        lst (list): The input list of integers.\n\n    Returns:\n        list: A new list containing only the positive numbers from the input list.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the input list contains non-integer values.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list.\")\n    \n    for i in lst:\n        if not isinstance(i, int):\n            raise ValueError(\"All elements of the input list should be integers.\")\n            \n    return [num for num in lst if num > 0]\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0.5, 0, -4, 2.5, 5, -2.2, -8, 7.7, 9.9, -10.5]]]}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "\ndef sort_even(lst):\n    \"\"\"This function takes a list lst and returns a new list where the elements at even indices are sorted.\n\n    Args:\n        lst (list): The input list to be processed.\n\n    Returns:\n        list: A new list with elements at even indices sorted.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list contains non-integer values.\n    \"\"\"\n    \n    # Check if lst is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list.\")\n        \n    # Check if all elements in lst are integers\n    for i in lst:\n        if not isinstance(i, int):\n            raise ValueError(\"All elements in the list should be integers.\")\n    \n    # Create a new list with elements at even indices sorted\n    sorted_even = [x for x in sorted(lst[::2])]\n    lst[::2] = sorted_even\n    \n    return lst\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[29.192135197854643, 33.66238184288656, 29.291147603502964]]]}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n        n: The upper limit for the range of numbers to check (non-inclusive).\n\n    Returns:\n        The total count of the digit 7 that appear in numbers divisible by 11 or 13 and less than n.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n            \n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "\ndef count_up_to(n):\n    \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n \n    integers that are prime numbers and less than n.\n\n    Args:\n        n: The upper limit for the prime number search (non-negative integer).\n\n    Returns:\n        A list of all prime numbers less than 'n'. If 'n' is less than or equal to 1, returns an empty list.\n\n    Raises:\n        TypeError: If 'n' is not an integer.\n        ValueError: If 'n' is negative.\n    \"\"\"\n    \n    if not isinstance(n, int):\n        raise TypeError(\"Input must be a non-negative integer.\")\n    elif n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n        \n    primes = []\n    for possible_prime in range(2, n):\n        is_prime = True\n        for num in range(2, possible_prime):\n            if possible_prime % num == 0:\n                is_prime = False                \n        if is_prime:\n            primes.append(possible_prime)\n    return primes\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[10000]]}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "\ndef below_threshold(lst: list, threshold: int) -> bool:\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n\n    Args:\n        lst: A list of integers.\n        threshold: An integer that serves as a limit for comparison with the elements in the list.\n\n    Returns:\n        A boolean value indicating whether all numbers in the list are less than the threshold.\n\n    Raises:\n        TypeError: If the input list contains non-integer values or if the threshold is not an integer.\n    \"\"\"\n    \n    # Checking if all elements in the list are integers\n    if not all(isinstance(i, int) for i in lst):\n        raise TypeError(\"All elements in the list must be integers.\")\n        \n    # Checking if threshold is an integer\n    if not isinstance(threshold, int):\n        raise TypeError(\"Threshold must be an integer.\")\n    \n    return all(i < threshold for i in lst)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[3.5, 2.2, 1.1], 5]]}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "\ndef closest_integer(value):\n    \"\"\"This function takes a string representing a number and returns the closest integer to it. \n    If the number is equidistant from two integers, it rounds away from zero.\n\n    Args:\n        value (str): A string representation of a floating point number.\n\n    Returns:\n        int: The closest integer to the input value.\n\n    Raises:\n        ValueError: If the input is not a valid floating point number.\n    \"\"\"\n    try:\n        num = float(value)\n        if num > 0:\n            return int(num + 0.5)\n        else:\n            return int(num - 0.5)\n    except ValueError as e:\n        raise ValueError(\"The input value is not a valid floating point number.\") from e\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "\ndef fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n\n    Args:\n        n (int): The position of the desired Fibonacci number in the sequence.\n\n    Returns:\n        int: The n-th Fibonacci number.\n\n    Raises:\n        ValueError: If input is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input should be greater than or equal to 1.\")\n    \n    a, b = 0, 1\n    for _ in range(n - 1):\n        a, b = b, a + b\n        \n    return b\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "\ndef fibfib(n: int) -> int:\n    \"\"\"Computes the n-th element of the FibFib number sequence.\n\n    The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n\n    Args:\n        n: The index of the element in the FibFib sequence.\n\n    Returns:\n        The n-th element of the FibFib sequence.\n\n    Raises:\n        ValueError: If n is less than 0.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n    \n    # Initialize base cases\n    fibfib_sequence = [0, 0, 1] + [0] * (n - 2)\n    \n    for i in range(3, n + 1):\n        fibfib_sequence[i] = fibfib_sequence[i-1] + fibfib_sequence[i-2] + fibfib_sequence[i-3]\n        \n    return fibfib_sequence[n]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "\ndef multiply(a: int, b: int) -> int:\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n\n    Args:\n        a: The first integer.\n        b: The second integer.\n\n    Returns:\n        The product of the unit digits of the input integers.\n\n    Raises:\n        TypeError: If either `a` or `b` is not an integer.\n    \"\"\"\n    \n    # Check if inputs are integers\n    if not all(isinstance(i, int) for i in [a, b]):\n        raise TypeError(\"Both arguments must be integers.\")\n        \n    return (abs(a) % 10) * (abs(b) % 10)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "\ndef next_smallest(lst):\n    \"\"\"\n    This function returns the 2nd smallest element of the list.\n\n    Args:\n        lst: A list of integers.\n\n    Returns:\n        The second smallest integer in the list, or None if there is no such element.\n\n    Raises:\n        ValueError: If the input is not a list or if it contains non-integer elements.\n    \"\"\"\n    \n    # Check that lst is a list and contains only integers\n    if not isinstance(lst, list):\n        raise ValueError(\"Input must be a list.\")\n    for i in lst:\n        if not isinstance(i, int):\n            raise ValueError(\"List must contain only integers.\")\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there are at least two elements in the list, return the second smallest\n    if len(unique_sorted) > 1:\n        return unique_sorted[1]\n    else:\n        return None\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "\ndef prime_fib(n: int):\n    \"\"\"\n    Returns the n-th number in the sequence of Fibonacci numbers that is also a prime number.\n\n    Args:\n        n (int): The position of the desired number in the sequence.\n\n    Returns:\n        int: The n-th Fibonacci prime number.\n\n    Raises:\n        ValueError: If n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    def is_prime(num):\n        \"\"\"Check if num is a prime number.\"\"\"\n        if num <= 1 or (num % 2 == 0 and num > 2): \n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    def fibonacci():\n        \"\"\"Generate Fibonacci numbers.\"\"\"\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n            \n    count = 0\n    for num in fibonacci():\n        if is_prime(num):\n            count += 1\n            if count == n:\n                return num\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[12]]}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "\ndef vowels_count(s):\n    \"\"\"Count the number of vowels in a string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of vowels in the string.\n\n    Raises:\n        TypeError: If the argument is not a string.\n    \"\"\"\n    \n    if not isinstance(s, str):\n        raise TypeError(\"The argument must be a string.\")\n        \n    count = 0\n    for char in s:\n        if char.lower() in 'aeiou':\n            count += 1\n            \n    # If the last character is 'y', also count it as a vowel\n    if s[-1].lower() == 'y':\n        count += 1\n        \n    return count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "\ndef simplify(x, n):\n    \"\"\"This function checks if the product of two fractions is a whole number.\n\n    Args:\n        x (str): The first fraction in the format 'numerator/denominator'.\n        n (str): The second fraction in the same format as x.\n\n    Returns:\n        bool: True if the product of x and n is a whole number, False otherwise.\n\n    Raises:\n        ValueError: If either x or n are not valid fractions.\n    \"\"\"\n    try:\n        # Split the string into numerator and denominator\n        x_num, x_denom = map(int, x.split('/'))\n        n_num, n_denom = map(int, n.split('/'))\n        \n        # Calculate the product of the fractions\n        product = (x_num * n_num) / (x_denom * n_denom)\n        \n        # Check if the product is a whole number\n        return product == int(product)\n    except ValueError:\n        raise ValueError(\"Both x and n must be valid fractions in the format 'numerator/denominator'\")\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    This function takes a sentence as input and returns a string containing the words from the original sentence whose lengths are prime numbers. \n\n    Args:\n        sentence (str): A string representing a sentence, with words separated by spaces.\n\n    Returns:\n        str: A string that contains the words from the original sentence whose lengths are prime numbers. The order of the words in the new string is the same as the original one.\n\n    Raises:\n        ValueError: If the length of the sentence exceeds 100 characters or if it contains non-alphabetical characters.\n        \n    \"\"\"\n    \n    def is_prime(n):\n        \"\"\"\n        This function checks whether a number is prime or not.\n\n        Args:\n            n (int): The number to be checked.\n\n        Returns:\n            bool: True if the number is prime, False otherwise.\n            \n        \"\"\"\n        \n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    # Check constraints\n    if len(sentence) > 100 or not sentence.replace(' ', '').isalpha():\n        raise ValueError(\"Invalid input\")\n        \n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    \n    return \" \".join(prime_words)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "\ndef exchange(lst1, lst2):\n    \"\"\"This function takes two lists of numbers as input and determines if it is possible to \n    perform an exchange operation between them to make all elements in the first list even.\n\n    Args:\n        lst1 (list): The first list of integers.\n        lst2 (list): The second list of integers.\n\n    Returns:\n        str: \"YES\" if it is possible to exchange elements between the lists to make all \n             elements in the first list even, otherwise \"NO\".\n\n    Raises:\n        TypeError: If either lst1 or lst2 is not a list.\n        ValueError: If either lst1 or lst2 contains non-integer values.\n    \"\"\"\n    \n    # Check if inputs are lists\n    if not (isinstance(lst1, list) and isinstance(lst2, list)):\n        raise TypeError(\"Both arguments must be of type 'list'\")\n        \n    # Check if all elements in both lists are integers\n    for i in lst1 + lst2:\n        if not isinstance(i, int):\n            raise ValueError(\"All elements in the list must be of type 'int'\")\n    \n    # If there exists an odd number in lst1 and no even number in lst2, return \"NO\"\n    for i in lst1:\n        if i % 2 != 0:\n            if all(j % 2 == 0 for j in lst2):\n                return \"NO\"\n    \n    # If none of the above conditions are met, return \"YES\"\n    return \"YES\"\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4], [1, 5, 3, 4]]], "plus_fail_tests": [[[1, 3, 5], [2, 4, 6]]]}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "\ndef prod_signs(arr):\n    \"\"\"Calculate the sum of magnitudes multiplied by product of all signs in an array.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The result of the operation if the input array is not empty, otherwise None.\n\n    Raises:\n        TypeError: If the input is not a list or contains non-integer elements.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input should be a list.\")\n    \n    # Check if all elements in the list are integers\n    for i in arr:\n        if not isinstance(i, int):\n            raise TypeError(\"All elements in the input list should be integers.\")\n    \n    # Return None for empty array\n    if len(arr) == 0:\n        return None\n    \n    # Calculate product of all signs and sum of magnitudes\n    prod = 1\n    sum_mag = 0\n    for i in arr:\n        prod *= (i > 0) - (i < 0)  # Convert positive to 1, negative to -1, zero to 0\n        sum_mag += abs(i)\n    \n    return prod * sum_mag\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "\ndef sum_odd_in_even_positions(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of all odd elements at even positions in the list.\n\n    Raises:\n        ValueError: If the input is not a list or if it contains non-integer values.\n    \"\"\"\n    \n    # Checking if the input is a list and if it's not empty\n    if not isinstance(lst, list) or len(lst) == 0:\n        raise ValueError(\"Input should be a non-empty list of integers\")\n        \n    # Checking if all elements in the list are integers\n    for i in lst:\n        if not isinstance(i, int):\n            raise ValueError(\"All elements in the list should be integers\")\n    \n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "\ndef select_words(s, n):\n    \"\"\"Given a string s and a natural number n, this function returns a list of all words \n    from string s that contain exactly n consonants, in order these words appear in the \n    string s. If the string s is empty then the function should return an empty list.\n    \n    Args:\n        s: A string containing only letters and spaces.\n        n: A natural number representing the exact number of consonants a word must have.\n        \n    Returns:\n        A list of words from string s that contain exactly n consonants, in order these \n        words appear in the string s. If no such words exist, returns an empty list.\n    \n    Raises:\n        TypeError: If s is not a string or if n is not a natural number.\n        \n    \"\"\"\n    # Checking if inputs are of correct type\n    if not isinstance(s, str):\n        raise TypeError(\"The first argument must be a string.\")\n    if not isinstance(n, int) or n < 0:\n        raise TypeError(\"The second argument must be a natural number.\")\n    \n    # Defining the set of consonants\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Splitting the string into words and filtering out those with n consonants\n    return [word for word in s.split() if sum(ch in consonants for ch in word) == n]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "\ndef match_parens(lst):\n    \"\"\"Check if it is possible to concatenate the two strings in some order, \n       that the resulting string will be good.\n\n    Args:\n        lst: A list of two strings, both strings consist of open parentheses '(' or close parentheses ')'.\n\n    Returns:\n        'Yes' if there's a way to make a good string, and 'No' otherwise.\n\n    Raises:\n        TypeError: If the input is not a list of two strings.\n        ValueError: If the strings in the list contain characters other than parentheses.\n    \"\"\"\n    \n    # Check if input is valid\n    if not isinstance(lst, list) or len(lst) != 2 or not all(isinstance(i, str) for i in lst):\n        raise TypeError(\"Input should be a list of two strings.\")\n        \n    if any(c not in '()' for s in lst for c in s):\n        raise ValueError(\"Strings can only contain parentheses.\")\n    \n    # Check all possible combinations\n    for i in range(2):\n        for j in range(2):\n            combined = lst[i] + lst[j]\n            \n            # Count open and close parentheses\n            count = 0\n            for c in combined:\n                if c == '(':\n                    count += 1\n                else:\n                    count -= 1\n                    \n                # If there's a closing parenthesis without a corresponding opening one, return 'No'\n                if count < 0:\n                    break\n            \n            # If all parentheses are balanced, return 'Yes'\n            if count == 0:\n                return 'Yes'\n    \n    return 'No'\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["()", "())"]]], "plus_fail_tests": [[["(())", ")()("]]]}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "\ndef is_sorted(lst):\n    \"\"\"Check if a list of numbers is sorted in ascending order and has no duplicates.\n\n    Args:\n        lst: A list of integers.\n\n    Returns:\n        True if the list is sorted and has no duplicates, False otherwise.\n\n    Raises:\n        ValueError: If the input list contains negative numbers or non-integer values.\n    \"\"\"\n    \n    # Check for invalid inputs\n    if not all(isinstance(i, int) and i >= 0 for i in lst):\n        raise ValueError(\"Input list must contain only non-negative integers.\")\n        \n    # Check if the list is sorted\n    if lst != sorted(lst):\n        return False\n    \n    # Check if there are duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    \n    return True\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, 3, 3, 4]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4]]]}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "\ndef sum_squares(lst):\n    \"\"\"This function takes a list of integers as input. It squares the integer entry if its index is a multiple of 3 and cubes the integer entry if its index is a multiple of 4 but not a multiple of 3. The function then returns the sum of all entries in the list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of all entries in the list after applying the specified operations.\n\n    Raises:\n        TypeError: If the input is not a list or if any element in the list is not an integer.\n    \"\"\"\n    \n    # Checking if the input is a list and if each element in the list is an integer\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list\")\n    for i in lst:\n        if not isinstance(i, int):\n            raise TypeError(\"All elements in the list should be integers\")\n    \n    # Initializing sum to 0\n    total_sum = 0\n    \n    # Iterating over each element in the list with its index\n    for i, val in enumerate(lst):\n        if i % 3 == 0:\n            # If index is a multiple of 3, square the value and add to sum\n            total_sum += val ** 2\n        elif i % 4 == 0:\n            # If index is a multiple of 4 but not 3, cube the value and add to sum\n            total_sum += val ** 3\n    \n    return total_sum\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "\ndef order_by_points(nums):\n    \"\"\"\n    This function sorts the given list of integers in ascending order according to \n    the sum of their digits. If there are several items with similar sum of their \n    digits, they are ordered based on their index in original list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: The sorted list according to the problem's specifications.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list contains non-integer values.\n    \"\"\"\n    \n    # Check if nums is a list\n    if not isinstance(nums, list):\n        raise TypeError(\"Input should be a list.\")\n        \n    # Check if all elements in nums are integers\n    for i in nums:\n        if not isinstance(i, int):\n            raise ValueError(\"All elements in the input list should be integers.\")\n    \n    # Sort the list based on the sum of digits and their original index\n    return sorted(nums, key=lambda x: (sum(int(digit) for digit in str(abs(x))), nums.index(x)))\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-5, -12, 9, 15]]]}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "\ndef get_closest_vowel(word):\n    \"\"\"Finds the closest vowel that stands between two consonants from the right side of a word.\n\n    Args:\n        word: The input string to search for the closest vowel.\n\n    Returns:\n        str: The closest vowel found or an empty string if no vowels are found.\n\n    Raises:\n        TypeError: If the provided argument is not a string.\n    \"\"\"\n    \n    # Check that word is a string\n    if not isinstance(word, str):\n        raise TypeError(\"The input must be a string.\")\n        \n    vowels = \"aeiouAEIOU\"\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    \n    # If no vowel is found\n    return \"\"\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["ali"]], "plus_fail_tests": []}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "\ndef intersection(interval1, interval2):\n    \"\"\"Determine if the length of the intersection of two intervals is a prime number.\n\n    Args:\n        interval1: A tuple representing the first interval.\n        interval2: A tuple representing the second interval.\n\n    Returns:\n        \"YES\" if the length of the intersection is a prime number, otherwise \"NO\".\n\n    Raises:\n        ValueError: If either interval is not a tuple or does not contain exactly two integers.\n    \"\"\"\n    \n    # Check that both intervals are tuples and contain exactly two integers\n    for interval in (interval1, interval2):\n        if not isinstance(interval, tuple) or len(interval) != 2:\n            raise ValueError(\"Each interval must be a tuple of two integers.\")\n    \n    # Calculate the intersection of the intervals\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    \n    # If there is no intersection, return \"NO\"\n    if start > end:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    length = end - start + 1\n    \n    # Check if the length is a prime number\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n            \n    return \"YES\"\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n        arr: A list of integers.\n        k: An integer representing the number of maximum elements to be returned.\n\n    Returns:\n        A sorted list of the k maximum elements from arr.\n\n    Raises:\n        ValueError: If k is greater than the length of arr or less than 0.\n    \n    \"\"\"\n    if not (0 <= k <= len(arr)):\n        raise ValueError(\"k must be between 0 and the length of arr\")\n        \n    # Sorting the array in descending order and returning the first k elements\n    return sorted(arr, reverse=True)[:k]\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "\ndef minPath(grid, k):\n    \"\"\"Find the minimum path of length k in the grid.\n\n    Args:\n        grid: A 2D list representing the grid with N rows and N columns (N >= 2).\n              Each cell contains a value from the range [1, N * N] inclusive.\n        k: The length of the path to find.\n\n    Returns:\n        An ordered list of the values on the cells that the minimum path go through.\n\n    Raises:\n        ValueError: If grid is not a 2D list with at least 2 rows and columns, or if k is less than 1.\n                     Or if any value in the grid does not appear exactly once.\n    \"\"\"\n    # Check for valid inputs\n    if not all(len(row) == len(grid) for row in grid):\n        raise ValueError(\"Grid must be a square\")\n    if k < 1:\n        raise ValueError(\"k must be at least 1\")\n    flat_grid = [item for sublist in grid for item in sublist]\n    if sorted(flat_grid) != list(range(1, len(grid)*len(grid)+1)):\n        raise ValueError(\"Each integer from 1 to N*N must appear exactly once\")\n    \n    # Initialize the minimum path as None and the visited cells set\n    min_path = None\n    visited = set()\n    \n    def dfs(cell, path):\n        nonlocal min_path\n        \n        # If we've reached a cell that's already in our path, return\n        if cell in path:\n            return\n        \n        # Add the current cell to the path and mark it as visited\n        path.append(cell)\n        visited.add(cell)\n        \n        # If we've found a valid path of length k, update our minimum path if necessary\n        if len(path) == k:\n            if min_path is None or path < min_path:\n                min_path = list(path)\n                \n        # Otherwise, continue the depth-first search from each neighbor cell\n        else:\n            row, col = divmod(cell - 1, len(grid))\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = row + dr, col + dc\n                if 0 <= nr < len(grid) and 0 <= nc < len(grid):\n                    neighbor_cell = grid[nr][nc]\n                    if neighbor_cell not in visited:\n                        dfs(neighbor_cell, path)\n        \n        # Remove the current cell from the path and mark it as unvisited\n        path.pop()\n        visited.remove(cell)\n    \n    # Start a depth-first search from each cell in the grid\n    for row in range(len(grid)):\n        for col in range(len(grid)):\n            dfs(grid[row][col], [])\n            \n    return min_path\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 9]]}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "\ndef sort_array(arr):\n    \"\"\"\n    This function sorts an array of non-negative integers according to the number of ones in their binary representation \n    in ascending order. For similar number of ones, it sorts based on decimal value.\n\n    Args:\n        arr: A list of non-negative integers.\n\n    Returns:\n        The sorted list of non-negative integers.\n\n    Raises:\n        ValueError: If the input list contains negative numbers.\n        \n    \"\"\"\n    \n    # Check if all elements in the array are non-negative\n    for num in arr:\n        if num < 0:\n            raise ValueError(\"All elements in the array must be non-negative.\")\n            \n    # Sort the array based on the number of ones in their binary representation and decimal value\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[[-2, -3, -4, -5, -6]]], "plus_fail_tests": []}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "\ndef string_sequence(n: int) -> str:\n    \"\"\"Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n\n    Args:\n        n (int): The upper limit of the sequence.\n\n    Returns:\n        str: A string with space-separated numbers from 0 to n inclusive.\n\n    Raises:\n        TypeError: If input is not an integer.\n        ValueError: If input is negative.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    elif n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    return ' '.join(str(i) for i in range(n + 1))\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "\ndef histogram(text):\n    \"\"\"Given a string representing a space separated lowercase letters, \n    return a dictionary of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Args:\n        text (str): A string of lowercase letters separated by spaces.\n        \n    Returns:\n        dict: A dictionary where keys are letters from the input string \n              and values are their corresponding counts in the string.\n              \n    Raises:\n        ValueError: If the input is not a string or contains non-lowercase letters.\n    \n    \"\"\"\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n        \n    if not text.replace(' ', '').isalpha() or not text.replace(' ', '').islower():\n        raise ValueError(\"Input can only contain lowercase letters and spaces.\")\n    \n    letter_counts = {}\n    for letter in text.split():\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n            \n    max_count = max(letter_counts.values(), default=0)\n    \n    return {k: v for k, v in letter_counts.items() if v == max_count}\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[""]], "plus_fail_tests": [[""]]}]}}