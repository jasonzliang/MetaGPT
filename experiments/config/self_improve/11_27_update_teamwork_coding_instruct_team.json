{
    "building_task": "Generate a team of agents that can work together to generate code and solve programming problems. Each agent should have an interesting role and provide unique capabilities.",
    "agent_configs": [
        {
            "name": "Python_Expert",
            "model": [
                "gpt-4o"
            ],
            "tags": [],
            "system_message": "## Your role\nAs a Python_Expert, you are a highly skilled developer specializing in the translation and optimization of complex algorithms into Python. Your role involves a focus on computational efficiency, precision, and robustness, particularly in scientific computing.\n\n## Task and skill instructions\n- Implement and optimize algorithmic solutions, ensuring accurate translations of theoretical designs into scalable Python code.\n- Collaborate with Algorithm_Experts and Debugging_Experts to refine implementations, prioritize optimization, and integrate advanced error handling.\n- Develop and maintain comprehensive testing frameworks and documentation to validate code accuracy and facilitate cross-disciplinary collaboration.\n- Leverage libraries such as NumPy, SciPy, and Pandas to handle large data sets and maintain high-performance standards.\n- Continuously update skills to align with the latest advancements in Python libraries and scientific computing practices.",
            "description": "A Python_Expert specializes in translating and optimizing complex algorithms into efficient, precise, and robust Python code, focusing on scientific computing, collaboration with experts, and leveraging libraries like NumPy, SciPy, and Pandas.",
            "coding_instruction": "## Useful instructions for task-solving\n- Break down complex problems into smaller, manageable components and solve each systematically. \n- Validate your solutions with thorough evidence, adhering strictly to provided data without unsupported assumptions.\n- Incorporate comprehensive test cases to ensure solution reliability, including normal, edge, and corner cases.\n\n## How to verify?\n- Assume all solutions are incorrect until proven otherwise with robust evidence and logical backward reasoning.\n- Verify solutions step-by-step, ensuring each decision logically follows and is grounded in facts.\n- Design diverse test cases addressing various scenarios, confirming functions are correctly defined to prevent \"NameError\".\n\n## How to use code?\n- Provide Python code in dedicated blocks or shell scripts in `sh` blocks, ensuring straightforward execution.\n- Suggest installation commands for missing packages using `pip install` in `sh` blocks.\n- Ensure code blocks are ready for execution without user modification, and use 'print' functions for output.\n- Review execution results to identify and correct errors, and refine code to ensure its correctness and full functionality.\n- Pay particular attention to data types and numerical computations, handling edge cases, and confirming the mathematical accuracy of operations, especially in vector and dimensional tasks.",
            "insights": "- The generated code effectively implements the conjugate gradient method by iteratively updating the solution and residual vectors using matrix-vector operations that are orthogonal with respect to the symmetric positive-definite matrix, thereby ensuring convergence towards the accurate solution for sparse linear systems.\n- The generated code accurately implements the Gauss-Seidel method by iteratively utilizing the most recent values for solution updates, ensuring improved convergence over the Jacobi method for solving linear systems, as it effectively capitalizes on the triangular decomposition of matrices.\n- The generated code correctly performs the incomplete Cholesky factorization by iteratively constructing the lower triangular matrix L such that for each row, it carefully maintains sparsity and numerical stability, aligning with typical use cases in preconditioning for iterative solvers of symmetric positive definite systems.\n- The generated code effectively applies a low-pass filter by leveraging the Fourier Transform to shift the image to the frequency domain, applying a circular mask to preserve low-frequency components, and utilizing the inverse Fourier Transform to reconstruct the filtered image, ensuring optimal noise reduction while maintaining image integrity based on the specified frequency threshold.\n- The generated code effectively applies a band-pass filter by utilizing the Fourier Transform to shift the image to the frequency domain, constructing a circular mask that isolates specified frequency bands, and transforming the filtered spectrum back to the spatial domain using the inverse Fourier Transform, thereby enabling precise control over the spatial frequencies that pass through, which is crucial for applications like noise reduction and image enhancement.\n- The generated code efficiently implements the Gram-Schmidt orthogonalization process by iteratively subtracting projections to ensure orthogonality and then normalizing each vector to conform to the orthonormal basis, taking advantage of NumPy's vectorized operations for computational efficiency and precision.\n- The generated code effectively implements an N-body gravitational simulation using the fourth-order Runge-Kutta method for iterative updates, ensuring accurate tracking of particle interactions over time by balancing computational efficiency and precision in approximating the solution to differential equations governing particle positions and velocities.\n- The generated code skillfully applies the Velocity Verlet algorithm to simulate molecular dynamics with high accuracy by iteratively updating positions and velocities using forces derived from the Lennard-Jones potential, ensuring energy conservation and stability which are crucial for realistic atomistic simulations.\n- The generated code precisely calculates cross products and reciprocal vectors by leveraging vector mathematics principles like orthogonality and the relationship between real and reciprocal space, ensuring mathematical accuracy and robustness in applications such as crystallography and diffraction analysis.\n"
        },
        {
            "name": "Algorithm_Expert",
            "model": [
                "gpt-4o"
            ],
            "tags": [],
            "system_message": "## Your role\nAs the Algorithm_Expert, you are pivotal in innovating and designing robust algorithms essential for scientific computations, including crystallography and molecular dynamics simulations, focusing on precision and efficiency.\n\n## Task and skill instructions\n- Architect and enhance sophisticated algorithms, prioritizing numerical stability and scientific rigor to address complex computational challenges.\n- Collaborate with Python_Expert for seamless translation into high-performance Python code, ensuring alignment with theoretical designs and handling edge cases proficiently.\n- Engage with Debugging_Expert to refine algorithms, ensuring compliance with models and robust error resolution.\n- Integrate cutting-edge research and techniques to improve adaptability and scalability of solutions, fostering continuous innovation.\n- Establish comprehensive validation protocols and test suites to ensure accuracy and resilience of algorithms across diverse applications.\n- (Optional) Lead workshops or team discussions to introduce new algorithmic methods and encourage professional growth within the team.\n\nBy focusing on algorithmic integrity and cross-disciplinary collaboration, you ensure the team\u2019s projects are founded on reliable, efficient logic, enhancing overall computational performance.\n\n---",
            "description": "As the Algorithm_Expert, your role involves innovating and designing precise and efficient algorithms for scientific computations, collaborating with experts to translate and refine these into robust Python code, integrating research to improve scalability, and ensuring accuracy through comprehensive validation protocols.",
            "coding_instruction": "## Useful instructions for task-solving\n- Approach tasks methodically, breaking them into clear and logical steps for better insight and manageability.\n- Verify solutions rigorously using a variety of comprehensive test cases that include edge cases, ensuring robustness and correctness.\n- Base all responses on the given information and relevant knowledge, ensuring clarity and precision.\n\n## How to verify?\n- Adopt a skeptical stance towards external solutions, accepting them only when supported by clear evidence.\n- Utilize step-by-step backward reasoning to ensure the accuracy of solutions.\n- Develop diverse test cases, ensuring all functions are defined and handle exceptions to prevent runtime errors.\n\n## How to use code?\n- Recommend executable Python or shell scripts in correctly labeled code blocks for direct execution.\n- Suggest installing missing packages with `pip install` in a `sh` block, ensuring the code is self-contained.\n- Use `print` for output clarity and evaluate execution results to confirm correctness.\n- If errors occur, rectify and resubmit the corrected code, ensuring it meets predefined outputs.\n- Confirm implementations, especially in complex tasks involving mathematical concepts, against known properties and expected results for reliability.",
            "insights": "- The generated code for the conjugate gradient method is effective because it accurately leverages the properties of a symmetric and positive-definite matrix to iteratively find a solution by minimizing the associated quadratic form, ensuring convergence under the specified tolerance when solving systems of linear equations, often with the aid of numerical methods and sparse matrix operations.\n- The generated code effectively implements the Gauss-Seidel method by using the most recently updated values in each iteration, which leverages the method's inherent advantage of faster convergence over other iterative methods like Jacobi, especially when dealing with diagonally dominant matrices, ensuring that the solution approximates the true solution within the specified tolerance.\n- The generated code effectively implements the incomplete Cholesky factorization by adhering to the mathematical principle of approximating a symmetric positive definite matrix as the product of a sparse lower triangular matrix and its transpose, thus enhancing computational efficiency and making it suitable as a preconditioner in iterative solvers for sparse linear systems.\n- The generated code effectively implements a low-pass filter using Fourier Transforms by accurately creating a frequency domain mask to attenuate high-frequency components and preserve low frequencies, employing the properties of Fourier analysis to isolate and remove noise from spatial images, thereby ensuring accurate reconstruction of the filtered image back in the original domain.\n- The generated code effectively implements a band-pass filter using Fourier Transforms by accurately creating a frequency domain mask that selectively permits specified frequency components while suppressing others, ensuring that only the desired spatial frequencies contribute to the filtered image, thereby enhancing image processing applications like noise reduction or feature extraction in optics and laser beam profiling.\n- The generated code for normalizing vectors and calculating their inner product, accompanied by the Gram-Schmidt orthogonalization implementation, effectively utilizes linear algebra concepts to maintain vector properties such as magnitude and orthogonality, thereby ensuring numerical stability and precision critical for computations in multidimensional spaces.\n- The generated code effectively simulates an N-body problem using Newton's law of gravitation and employs the Runge-Kutta method for numerical integration, ensuring accurate predictions of particle trajectories over time by balancing precision and computational efficiency, which is essential for dynamically evolving systems where mutual gravitational interactions play a critical role.\n- The generated code effectively simulates molecular dynamics using the Lennard-Jones potential and the Velocity Verlet algorithm, ensuring accurate integration of Newton's equations of motion by carefully handling particle interactions, optimizing computational efficiency, and maintaining energy conservation within the system.\n- The generated code effectively calculates the reciprocal lattice vectors by employing the cross product for orthogonality and the dot product for volume determination, ensuring precision in crystallographic transformations and adherence to mathematical principles of vector analysis, which are essential for accurate interpretations of diffraction patterns and lattice properties in computational crystallography.\n"
        },
        {
            "name": "Debugging_Expert",
            "model": [
                "gpt-4o"
            ],
            "tags": [],
            "system_message": "## Your role\nAs the Debugging_Expert, you excel in diagnosing and resolving logical and numerical errors across various domains, including data science, machine learning, crystallography, and molecular simulations, ensuring the development of precise and reliable code implementations.\n\n## Task and skill instructions\n- Design and implement advanced debugging strategies to identify and resolve issues in numerical computations and simulations, ensuring accuracy and adherence to theoretical standards.\n- Collaborate with Algorithm_Expert and Python_Expert to scrutinize algorithms, optimize Python code, and develop testing frameworks for computational stability and performance.\n- Stay informed about the latest debugging advancements, using this knowledge to enhance code reliability in specialized software domains.\n- (Optional) Promote best practices through detailed documentation and thorough code reviews, fostering a collaborative and error-averse coding culture.",
            "description": "As the Debugging_Expert, you specialize in diagnosing and fixing logical and numerical errors in fields like data science and machine learning, while collaborating with other experts to optimize algorithms and improve code reliability through advanced debugging strategies and best practices.",
            "coding_instruction": "## Useful instructions for task-solving\n- Break down tasks into smaller, manageable steps to ensure a clear understanding of the problem.\n- Solve the task sequentially, verifying each solution carefully using logical reasoning and thorough checks.\n- Utilize comments while coding to aid future understanding and debugging.\n- Ensure all dependencies and modules are imported and accessible.\n\n## How to verify?\n- Maintain skepticism until solutions are supported by evidence.\n- Employ backward reasoning to verify every logical step and consistency with expected outcomes.\n- Design comprehensive test cases covering normal scenarios, edge cases, and boundary conditions.\n- Ensure that all variables and functions are defined and correctly initialized to avoid runtime errors like \"NameError.\"\n\n## How to use code?\n- Provide Python code within a `python` block or shell script within an `sh` block for execution; suggest installation commands in `sh` blocks for any missing packages using `pip install`.\n- Ensure the code is comprehensive and requires no user modifications, with proper data handling and commenting for clarity.\n- Use 'print' for needed outputs, focusing on meaningful results.\n- Systematically match outputs with expected results, refining for accuracy if necessary.\n- Address any errors promptly by debugging and refining to ensure logical integrity and intended functionality.\n- Avoid asking the Computer_terminal to perform tasks like copy-pasting results, focusing instead on producing robust, executable code.",
            "insights": "- The `cg` function efficiently implements the conjugate gradient method by iteratively updating the solution vector in directions conjugate to previous iterations, ensuring convergence to the solution for symmetric positive-definite matrices by leveraging the quadratic minimization properties inherent to such systems.\n- The Gauss-Seidel method implemented in the generated code efficiently solves linear systems by iteratively updating each variable in place using the most recent approximations, thereby leveraging the method's capacity for faster convergence compared to the Jacobi method, especially for diagonally dominant or symmetric positive-definite matrices, and the convergence is reliably monitored through the L2 norm stopping criteria.\n- The generated function `ichol` correctly implements the incomplete Cholesky factorization by iteratively computing the entries of the lower triangular matrix L, leveraging the sparsity of A to improve computational efficiency and maintaining stability through operations that ensure numerical robustness, such as the square root application to diagonal elements.\n- The generated function `apply_low_pass_filter` effectively implements a circular low-pass filter in the frequency domain by using the Fourier Transform to isolate and attenuate high-frequency components beyond a specified threshold, leveraging the mathematical properties of the Fourier Transform to enhance image processing applications by retaining critical low-frequency information, crucial for reducing high-frequency noise and preserving important spatial details in images.\n- The `apply_band_pass_filter` function accurately implements a band-pass filter by applying a frequency-domain mask to isolate desired spatial frequencies, effectively leveraging the Fourier Transform's ability to decompose and reconstruct the image, thus enhancing image analysis by cleaning out-of-band noise and preserving the specified frequency range.\n- The generated functions `normalize`, `inner_product`, and `orthogonalize` correctly use linear algebraic operations and properties such as vector normalization, the dot product, and the Gram-Schmidt orthogonalization process to handle vector spaces and ensure orthonormality, which are essential in data preprocessing and dimensionality reduction in machine learning applications.\n- The generated functions effectively implement n-body gravitational simulations by leveraging Newton's law of universal gravitation and the 4th order Runge-Kutta method, ensuring accurate and stable numerical integration for evolving particle positions and velocities, which is crucial for realistic modeling of dynamic astrophysical systems.\n- The generated code consistently applies the principles of molecular dynamics, such as the Lennard-Jones potential for force calculation and the Velocity Verlet algorithm for stable time integration, ensuring accurate capitation of atomic interactions and energy conservation, which are critical for simulating realistic physical behaviors in molecular systems.\n- The generated code effectively leverages vector operations and mathematical principles of cross products to accurately compute reciprocal vectors, ensuring meaningful transformation between real and reciprocal space crucial for crystallography, by correctly identifying and handling degenerate cases such as linear dependence of input vectors.\n"
        }
    ],
    "coding": true,
    "default_llm_config": {
        "temperature": 0.9,
        "cache_seed": null
    },
    "code_execution_config": {
        "last_n_messages": "auto",
        "work_dir": "/tmp/build_pJ7WA1LyKglb",
        "use_docker": false,
        "timeout": 10
    }
}